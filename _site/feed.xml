<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-25T03:46:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">갱로그</title><subtitle>&quot;bokyung&apos;s blog&quot;</subtitle><author><name>BoKyung</name></author><entry><title type="html">[DEV] 2주차. 파이썬으로 웹 다루기(2)</title><link href="http://localhost:4000/data%20engineering/2023/10/24/1024.html" rel="alternate" type="text/html" title="[DEV] 2주차. 파이썬으로 웹 다루기(2)" /><published>2023-10-24T00:00:00+09:00</published><updated>2023-10-25T03:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/24/1024</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/24/1024.html"><![CDATA[<h2 id="1-인터넷">1. 인터넷</h2>

<ul>
  <li>WWW : 인터넷에서 정보를 교환할 수 있는 환경 (World Wide Web)</li>
  <li>여러 컴퓨터끼리 네트워크를 연결한 것</li>
  <li>Web은 인터넷 상에서 정보를 교환하기 위한 시스템</li>
</ul>

<h2 id="2-web에서-정보-주고받기">2. Web에서 정보 주고받기</h2>

<ul>
  <li><strong>클라이언트</strong> : 정보 요청</li>
  <li><strong>서버</strong> : 정보 제공</li>
</ul>

<p>1) 클라이언트가 서버에게 정보를 요청   <br />
2) 요청에 대해서 서버가 작업 수행    <br />
3) 수행한 작업의 결과를 클라이언트에게 응답</p>

<h2 id="3-http">3. HTTP</h2>

<ul>
  <li>Hypertext Transfer Protocol</li>
  <li>
    <p>웹 상에서 정보를 주고받기 위한 약속</p>
  </li>
  <li>HTTP 요청 (Request)
    <ul>
      <li>클라이언트에서 서버로 정보를 요청하는 것</li>
    </ul>
  </li>
  <li>HTTP 응답 (Response)
    <ul>
      <li>요청된 정보에 대해 서버가 클라이언트에게 응답하는 것</li>
    </ul>
  </li>
</ul>

<h3 id="http-구조">HTTP 구조</h3>
<ul>
  <li>HEAD
    <ul>
      <li>요청/응답에 대한 정보</li>
    </ul>
  </li>
  <li>BODY
    <ul>
      <li>내용물 (정보)</li>
    </ul>
  </li>
</ul>

<h4 id="httprequest---header">HTTPRequest - Header</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP 1.1
Host: www.programmers.com
User-Agent: Mozilla/5.0
...
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GET</code> 키워드
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/</code> : root. 가장 최상단의 정보</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">HOST</code>
    <ul>
      <li>누구의 정보를 요청하는지</li>
      <li>www.programers.com 의 <code class="language-plaintext highlighter-rouge">/</code> 정보</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">User-Agent</code>
    <ul>
      <li>사용자 정보 (요청하는 자)</li>
    </ul>
  </li>
</ul>

<h4 id="httpresponse">HTTPResponse</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP / 1.1 200 OK
///
&lt;html&gt;...&lt;/html&gt;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">OK</code>
    <ul>
      <li>잘 왔다는 시그널</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;html&gt;...&lt;/html&gt;</code>
    <ul>
      <li>요청했던 정보</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">200</code>
    <ul>
      <li>status code</li>
      <li>ex)
        <ul>
          <li>404 : Not Found</li>
          <li>503 : Server Error</li>
          <li>위 경우 정보가 오지 않을 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="4-웹페이지">4. 웹페이지</h2>

<ul>
  <li>웹페이지
    <ul>
      <li>HTML 형식</li>
    </ul>
  </li>
  <li>웹브라우저
    <ul>
      <li>우리가 HTML 요청을 보내고, HTTP 응답에 담긴 HTML 문서를 우리가 보기 쉬운 형태로 화면을 그려주는 역할</li>
      <li>HTML 코드 렌더링</li>
    </ul>
  </li>
</ul>

<h2 id="5-html-구조">5. HTML 구조</h2>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>Example Document<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
    <span class="nt">&lt;body&gt;</span>
        <span class="nt">&lt;h1&gt;</span>Hello World!<span class="nt">&lt;/h1&gt;</span>
        <span class="nt">&lt;p&gt;</span>My name is BK!<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE html&gt;</code>
    <ul>
      <li>HTML5 임을 명시</li>
    </ul>
  </li>
  <li>
    <p>가장 바깥에 <code class="language-plaintext highlighter-rouge">&lt;html&gt;</code> 태그로 감싸져 있음</p>
  </li>
  <li>크게 <strong>Head</strong>와 <strong>Body</strong>로 나눌 수 있음</li>
  <li>Head
    <ul>
      <li>문서에 대한 정보 (제목, 언어 등) 작성</li>
    </ul>
  </li>
  <li>Body
    <ul>
      <li>문서의 내용 (글, 이미지, 동영상 등) 작성</li>
    </ul>
  </li>
  <li>HTML은 여러 <strong>태그(Tag)</strong>로 감싼 <strong>요소(Element)</strong>의 집합으로 이루어져 있음!</li>
  <li>태그로 내용을 묶어 글의 형식 지정</li>
  <li>태그는 그에 맞는 속성(attribute)를 가지기도 함</li>
</ul>

<h2 id="6-http-통신-코드">6. HTTP 통신 코드</h2>

<h3 id="get--정보-요청">GET : 정보 요청</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># requests 라이브러리 불러온 후, NAVER의 홈페이지 요청하여 응답 받기
</span><span class="kn">import</span> <span class="n">requests</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">https://www.naver.com</span><span class="sh">"</span><span class="p">)</span>
<span class="n">res</span>
</code></pre></div></div>
<p>&lt;Response [200]&gt;  :  OK</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Header 확인 : .headers
</span>
<span class="n">res</span><span class="p">.</span><span class="n">headers</span>
</code></pre></div></div>
<p><img width="707" alt="스크린샷 2023-10-25 오전 2 14 28" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/40b065f5-0a9e-498b-a88b-1f9ef7f06624" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Body 텍스트 형태로 확인 : .text
</span>
<span class="n">res</span><span class="p">.</span><span class="n">text</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
</code></pre></div></div>
<p><img width="684" alt="스크린샷 2023-10-25 오전 2 16 54" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/3c023f29-0ed3-4f49-be37-102d68af6849" /></p>

<h3 id="post--정보-갱신-요청">POST : 정보 갱신 요청</h3>

<ul>
  <li>사용자의 정보를 제공하면서 서버에게 무언가 요청을 진행하는 경우</li>
  <li>ex) 로그인
    <ul>
      <li>ID, PWD 제공 -&gt; 서버에게 전달</li>
      <li>서버 : 클라이언트에서 보내온 정보가 서버에 있는 이 사용자의 ID, PWD와 일치하는지 확인</li>
    </ul>
  </li>
</ul>

<p><a href="https://webhook.site">https://webhook.site</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># payload와 함께 POST 보내기 : requests.post()
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">Hello</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">13</span><span class="p">}</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="sh">"</span><span class="s">https://webhook.site/5dd86a17-4493-4c3c-ac7f-0b968cb03296</span><span class="sh">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>request의 body에 정보 전달
    <ul>
      <li>간단하게 dictionary 이용</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># status code 확인 : .status_code
</span>
<span class="n">res</span><span class="p">.</span><span class="n">status_code</span>
</code></pre></div></div>

<p>200</p>

<p><img width="653" alt="스크린샷 2023-10-25 오전 2 33 55" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/a79801a8-4a7b-41fb-9e41-d236da464224" /></p>

<h2 id="7-웹-크롤링과-웹-스크래핑">7. 웹 크롤링과 웹 스크래핑</h2>

<ul>
  <li>웹 스크래핑
    <ul>
      <li>웹페이지들로부터 우리가 원하는 정보를 <strong>추출</strong></li>
      <li>ex) 프로그래머스 플랫폼 속엔 어떤 프로그래밍 문제들이 있지?</li>
      <li>특정한 목적으로 특정 웹페이지에서 데이터를 추출하는 것
        <ul>
          <li>ex) 날씨 데이터 가져오기, 주식 데이터 가져오기, …</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>웹 크롤링
    <ul>
      <li>크롤러(Crawler)를 이용해서 웹 페이지의 정보를 <strong>인덱싱</strong></li>
      <li>ex) 프로그래머스 플랫폼 속엔 어떤 페이지들이 있지?</li>
      <li>URL을 타고다니며 반복적으로 데이터를 가져오는 과정
        <ul>
          <li>ex) 검색 엔진의 웹 크롤러</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="8-올바르게-http-요청하기">8. 올바르게 HTTP 요청하기</h2>

<ul>
  <li>웹 스크래핑/크롤링을 통해 <strong>어떤 목적</strong>을 달성하고자 하는가?</li>
  <li>나의 웹 스크래핑/크롤링이 <strong>서버에 영향</strong>을 미치지는 않는가?</li>
</ul>

<h3 id="robotstxt">robots.txt</h3>
<ul>
  <li>웹사이 및 웹페이지를 수집하는 로봇들의 무단 접근을 방지하기 위해 만들어진 로봇 배제 표준</li>
  <li><code class="language-plaintext highlighter-rouge">User-agent</code>, <code class="language-plaintext highlighter-rouge">Disallow</code>, <code class="language-plaintext highlighter-rouge">Allow</code> 이용
    <ul>
      <li>User-agent : 규칙이 적용되는 대상 사용자 에이전트</li>
      <li>Disallow : 크롤링을 금지할 웹페이지</li>
      <li>Allow : 크롤링을 허용할 웹페이지</li>
    </ul>
  </li>
  <li>robots.txt 가져오기</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">requests</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">https://www.naver.com/robots.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p>User-agent: *    <br />
Disallow: /     <br />
Allow: /$</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/$</code> : 순수하게 <code class="language-plaintext highlighter-rouge">/</code>로 끝나는 페이지
    <ul>
      <li>위의 경우 <code class="language-plaintext highlighter-rouge">https://www.naver.com/</code> 만 허용하겠다는 뜻</li>
    </ul>
  </li>
</ul>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. 인터넷]]></summary></entry><entry><title type="html">[DEV] 2주차. 파이썬으로 웹 다루기(1)</title><link href="http://localhost:4000/data%20engineering/2023/10/23/1023.html" rel="alternate" type="text/html" title="[DEV] 2주차. 파이썬으로 웹 다루기(1)" /><published>2023-10-23T00:00:00+09:00</published><updated>2023-10-24T03:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/23/1023</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/23/1023.html"><![CDATA[<h2 id="1-html">1. HTML</h2>
<ul>
  <li>Hypertext Markup Language</li>
  <li>웹 브라우저가 이해할 수 있는 언어</li>
</ul>

<h2 id="2-html-기본-문법">2. HTML 기본 문법</h2>

<h3 id="태그">태그</h3>
<ul>
  <li>컨텐츠를 가지는 태그
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;div&gt; 컨텐츠 &lt;/div&gt;</code></li>
    </ul>
  </li>
  <li>컨텐츠를 가지지 않는 태그
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;br /&gt;</code></li>
    </ul>
  </li>
</ul>

<h3 id="속성과-값">속성과 값</h3>
<p><code class="language-plaintext highlighter-rouge">&lt;div title="제목"&gt;Content&lt;/div&gt;</code></p>
<ul>
  <li>title : 속성</li>
  <li>“제목” : 값</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">&lt;a href="https://naver.com"&gt;네이버 바로가기&lt;/a&gt;</code></p>
<ul>
  <li>href : 속성</li>
  <li>“https://naver.com” : 값</li>
  <li>네이버 바로가기 : 콘텐츠</li>
</ul>

<h3 id="html-기본-문서">HTML 기본 문서</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>     <span class="c">&lt;!-- 문서 버전 --&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"KO"</span><span class="nt">&gt;</span>    <span class="c">&lt;!-- HTML 문서 시작 선언 및 문서 기본 언어 설정 --&gt;</span>
    <span class="nt">&lt;head&gt;</span>      <span class="c">&lt;!-- 문서에 필요한 정보가 기입되는 곳 --&gt;</span>
        <span class="nt">&lt;title&gt;</span>문서 제목<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/head&gt;</span>

    <span class="nt">&lt;body&gt;</span>       <span class="c">&lt;!-- 실제 사용자가 눈으로 볼 수 있는 문서의 내용이 입력되는 곳 --&gt;</span>
        안녕하세요!
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h3 id="부모요소-자식요소">부모요소 자식요소</h3>
<p><code class="language-plaintext highlighter-rouge">html</code>     <br />
|- <code class="language-plaintext highlighter-rouge">head</code>     <br />
|      ㄴ <code class="language-plaintext highlighter-rouge">title</code>     <br />
ㄴ <code class="language-plaintext highlighter-rouge">body</code></p>

<ul>
  <li>올바른 코드의 depth 를 지키는 것이 아주 중요함!</li>
</ul>

<h3 id="주석">주석</h3>
<ul>
  <li>
    <p>개발자가 코드 내에 입력한 메모
<code class="language-plaintext highlighter-rouge">&lt;!-- comment --&gt;</code></p>
  </li>
  <li>주석 안에 주석은 안됨!</li>
  <li>소스 보기나 개발자 도구로 보면 코드가 보이니 중요한 정보는 작성하면 안됨!</li>
</ul>

<h2 id="3-head">3. HEAD</h2>

<h3 id="head-태그">head 태그</h3>

<ul>
  <li>
    <p>사람의 눈에는 보이지 않지만 <strong>문서의 정보</strong>가 담기는 영역</p>
  </li>
  <li>
    <p>ex</p>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>문서 제목<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div></div>

<h4 id="head-태그가-가질-수-있는-정보의-종류">head 태그가 가질 수 있는 정보의 종류</h4>

<ul>
  <li>
    <p>타이틀</p>
  </li>
  <li>
    <p>메타 데이터</p>
    <ul>
      <li>인코딩 정보
        <ul>
          <li><code class="language-plaintext highlighter-rouge">charset</code>은 문서에서 허용하는 문자의 집합</li>
          <li><code class="language-plaintext highlighter-rouge">charset</code>에 선언된 <strong>문자의 집합</strong> 규칙에 따라 문서에서 사용할 수 있는 문자가 제한됨</li>
        </ul>
      </li>
      <li>문서 설명</li>
      <li>문서 작성자</li>
    </ul>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>문서 제목<span class="nt">&lt;/title&gt;</span>

    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"description"</span> <span class="na">content=</span><span class="s">"이 문서는 실습 문서입니다."</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"author"</span> <span class="na">content=</span><span class="s">"bokyung"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div></div>

<ul>
  <li>CSS, Script</li>
</ul>

<h3 id="style-link-script-태그">style, link, script 태그</h3>
<ul>
  <li>문서 내용의 외형에 영향을 주는 태그들</li>
</ul>

<h4 id="style-태그">style 태그</h4>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;style&gt;</span>
        <span class="nt">p</span> <span class="p">{</span>
            <span class="nl">color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div></div>

<h4 id="link-태그">link 태그</h4>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rel</code>: 지금 링크된 파일</li>
  <li><code class="language-plaintext highlighter-rouge">href</code> : 링크할 파일 (stylesheet)의 경로</li>
</ul>

<h4 id="script-태그">script 태그</h4>

<ul>
  <li>콘텐츠 방식</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
    <span class="kd">const</span> <span class="nx">hello</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<ul>
  <li>링크 방식
    <ul>
      <li>컨텐츠를 가지지 않지만, 반드시 종료태그 <code class="language-plaintext highlighter-rouge">&lt;/script&gt;</code> 를 작성해야 함</li>
    </ul>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"script.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<h2 id="4-body">4. BODY</h2>

<h3 id="body-태그">body 태그</h3>

<ul>
  <li>사람의 눈에 실제로 보이는 컨텐츠 영역</li>
</ul>

<h3 id="block-레벨-요소">block 레벨 요소</h3>

<ul>
  <li>레고 블록처럼 차곡차곡 쌓이고, 화면 너비가 꽉 차는 요소
    <ul>
      <li>블록의 크기와 내/외부에 여백을 지정할 수 있고, 일반적으로 <strong>페이지의 구조적 요소</strong>를 나타냄</li>
      <li>인라인 요소를 포함할 수 있으나, 인라인 요소에 포함될 수 없음</li>
    </ul>
  </li>
  <li>대표적인 블록 레벨 요소
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code>, …</li>
    </ul>
  </li>
</ul>

<h4 id="예시">예시</h4>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"KO"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>문서 제목<span class="nt">&lt;/title&gt;</span>
        
        <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/head&gt;</span>

    <span class="nt">&lt;body&gt;</span>
        <span class="nt">&lt;div&gt;</span>블록1<span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div&gt;</span>블록2<span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div&gt;</span>블록3<span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img width="1440" alt="스크린샷 2023-10-24 오후 3 43 33" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/718e5154-d85b-4548-816e-ecbb0a36eb40" /></p>

<h3 id="inline-레벨-요소">inline 레벨 요소</h3>
<ul>
  <li>블록 요소 내에 포함되는 요소
    <ul>
      <li>주로 문장, 단어같은 작은 부분에 사용되며, 한 줄에 나열됨</li>
      <li>크기는 줄 수 없고, 좌/우에 여백을 넣는 것만 허용됨</li>
    </ul>
  </li>
  <li>대표적인 인라인 레벨 요소
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code></li>
    </ul>
  </li>
</ul>

<h4 id="예시-1">예시</h4>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"KO"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>문서 제목<span class="nt">&lt;/title&gt;</span>
        
        <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"style.css"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/head&gt;</span>

    <span class="nt">&lt;body&gt;</span>
        <span class="nt">&lt;span&gt;</span>인라인<span class="nt">&lt;/span&gt;</span> 인라인 옆 글자
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">span</span> <span class="p">{</span>
    <span class="nl">padding-left</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="nl">padding-top</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>   <span class="c">/* 적용되지 않음 */</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img width="1440" alt="스크린샷 2023-10-24 오후 3 45 49" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/b1a8c872-0ba6-4816-bbe5-f715be216362" /></p>

<h3 id="inline-block-레벨-요소">inline-block 레벨 요소</h3>
<ul>
  <li>글자처럼 취급되나, block 태그의 성질을 가지는 요소
    <ul>
      <li>block과 마찬가지로 크기와 내/외부 여백 지정할 수 있음</li>
      <li>CSS로 성질을 바꾼 것이기 때문에 의미상 인라인 레벨 요소임</li>
    </ul>
  </li>
</ul>

<h2 id="5-레이아웃">5. 레이아웃</h2>

<h3 id="div-태그">div 태그</h3>
<ul>
  <li>가장 흔히 사용되는 레이아웃 태그로, 단순히 구역을 나누기 위한 태그</li>
</ul>

<h3 id="header-태그">header 태그</h3>
<ul>
  <li>블로그 글, 제목, 작성일 등의 주요 정보를 담는 태그</li>
</ul>

<h3 id="footer-태그">footer 태그</h3>
<ul>
  <li>페이지의 바닥줄에 사용되며 저작권 정보, 연락처 등 부차적인 정보를 담는 태그</li>
</ul>

<h3 id="main-태그">main 태그</h3>
<ul>
  <li>페이지의 가장 큰 부분으로 사이트의 내용, 즉 주요 컨텐츠를 담는 태그</li>
  <li>한 페이지에 한 번만 나와야 함!
    <ul>
      <li>header, footer는 여러 번 가능</li>
    </ul>
  </li>
</ul>

<h3 id="section-태그">section 태그</h3>
<ul>
  <li>컨텐츠의 구역을 나누는 태그</li>
</ul>

<h3 id="article-태그">article 태그</h3>
<ul>
  <li>section의 구역 안에서 작성된, 블로그 포스트, 뉴스 기사와 같은 독립적인 문서를 전달하는 태그</li>
</ul>

<h3 id="aside-태그">aside 태그</h3>
<ul>
  <li>문서의 주요 내용에 간접적인 정보를 전달하는 태그
    <ul>
      <li>쇼핑몰 오른쪽에 따라다니는 “오늘 본 상품” 과 같은 것으로 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="레이아웃-태그를-알아야-하는-이유">레이아웃 태그를 알아야 하는 이유</h3>
<ul>
  <li>HTML5부터 태그를 의미있게 사용하기 위해 <strong>Semantic(시맨틱)</strong> 태그를 사용하여 문서 구조를 작성</li>
  <li>단순히 의미 구분자인 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>를 남발하지 않고, 적절한 태그를 사용하여 웹 문서가 담은 정보와 구조를 의미있게 전달</li>
  <li>시맨틱하게 마크업을 함으로싸 검색엔진의 검색 순위에 가산점을 얻거나 홈페이지의 로딩 속도를 높임</li>
</ul>

<h2 id="6-컨텐츠">6. 컨텐츠</h2>

<h3 id="1-제목-태그-h1--h6">1) 제목 태그 (h1 ~ h6)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code> ~ <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code></li>
  <li>문서 <strong>구획 제목</strong>을 나타내는 태그로, heading (헤딩) 태그라고 부름
    <ul>
      <li>h1부터 h6까지 사용 가능</li>
      <li>h1 태그는 페이지 내에 <strong>한번만</strong> 사용되어야 하고, <strong>구획의 순서</strong>는 지켜져야 함
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">&lt;h3&gt;</code> 태그 다음에 <code class="language-plaintext highlighter-rouge">&lt;h5&gt;</code> 태그가 나올 수 없음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-문단-태그-p">2) 문단 태그 (p)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;p&gt;</code></li>
  <li>문서에서 하나의 <strong>문단</strong> (paragraph) 을 나타내는 태그
    <ul>
      <li>제목 태그와 함께 사용되기도 하고 단독으로 사용되기도 함</li>
      <li>레이아웃처럼 사용하면 안됨!</li>
    </ul>
  </li>
</ul>

<h3 id="3-서식-태그-bstrong-iem-u-sdel">3) 서식 태그 (b/strong, i/em, u, s/del)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;b&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code></li>
  <li>글씨의 <strong>두께</strong> 조절
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;b&gt;</code> 태그는 의미를 가지지 않고 단순히 굵은 글씨로 변경만 해줌</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;strong&gt;</code> 태그는 굵은 글씨로 변경 후 <strong>강조</strong>의 의미 부여</li>
      <li>시각적으로 굵은 효과는 같지만, 의미가 다르므로 사용에 주의!</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;i&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;em&gt;</code></li>
  <li>글씨의 <strong>기울기</strong> 조절
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;i&gt;</code> 태그는 기울임과 동시에 텍스트가 문단의 내용과 구분되어야 하는 경우 사용
        <ul>
          <li>ex) 등장인물 이름, 외국어 구절, 기술 용어 등</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">&lt;em&gt;</code> 태그는 기울임과 동시에 내용의 <strong>강조</strong>를 나타냄</li>
      <li>시각적으로 기울림은 같지만, 의미가 다르므로 사용에 주의!</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;u&gt;</code></li>
  <li>글씨에 <strong>밑줄</strong>을 넣고 주석을 가지는 단어임을 나타냄
    <ul>
      <li>CSS로 스타일링하여 빨간 밑줄을 넣는 것으로 “오타”를 나타내는 것처럼 사용할 수 있음</li>
      <li>단순하게 “밑줄”만 긋는 용도로는 사용하면 안됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;s&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;del&gt;</code></li>
  <li>글씨에 <strong>취소선</strong> 추가
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;s&gt;</code> 태그는 단순히 시각적인 취소선만 추기되고, 접근성 기기에 취소에 대한 안내는 하지 않음</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;del&gt;</code> 태그는 문서에서 제거된 텍스트를 나타낼 수 있음
        <ul>
          <li><code class="language-plaintext highlighter-rouge">&lt;ins&gt;</code> 태그를 함께 사용하면 제거된 텍스트 옆에 추가된 텍스트를표현할 수 있음</li>
          <li><code class="language-plaintext highlighter-rouge">&lt;del&gt;캐ㅍ&lt;/del&gt;&lt;ins&gt;캐스퍼&lt;/ins&gt;입니다.</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-링크-이동">3) 링크 이동</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;a&gt;</code></li>
  <li>클릭하면 페이지를 이동할 수 있는 링크 요소 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">href</code> 속성을 사용해서 이동하고자 하는 파일 혹은 URL 작성</li>
      <li><code class="language-plaintext highlighter-rouge">target</code> 속성을 사용해서 이동해야 할 링크를 새창(_blank), 현재창(_self) 등 원하는 타겟 지정 가능</li>
    </ul>
  </li>
</ul>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. HTML]]></summary></entry><entry><title type="html">[DEV] 1주차. 자료구조/알고리즘(5)</title><link href="http://localhost:4000/data%20engineering/2023/10/20/1020.html" rel="alternate" type="text/html" title="[DEV] 1주차. 자료구조/알고리즘(5)" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-21T03:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/20/1020</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/20/1020.html"><![CDATA[<h2 id="1-heap-대표-문제---더-맵게">1. Heap 대표 문제 - 더 맵게</h2>

<h3 id="heaps">Heaps</h3>
<p><img width="362" alt="스크린샷 2023-10-20 오후 6 56 15" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/532ffaae-955b-4506-b7ab-8d2f05d09ad5" /></p>

<ul>
  <li>최대/최소 원소를 상수 시간으로 빠르게 찾을 수 있음</li>
  <li>연산
    <ul>
      <li>힙 구성 (heapify)
        <ul>
          <li>$O(nlogn)$</li>
        </ul>
      </li>
      <li>삽입 (insert)
        <ul>
          <li>$O(logn)$</li>
        </ul>
      </li>
      <li>삭제 (remove)
        <ul>
          <li>최대/최소 원소를 하나 꺼내서 없애는 것</li>
          <li>$O(logn)$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>완전 이진 트리
    <ul>
      <li>배열을 이용해서 구현 가능!</li>
      <li>공간 효율성이 높음</li>
    </ul>
  </li>
  <li>응용
    <ul>
      <li>정렬 (heap sort)
        <ul>
          <li>$O(nlogn)$</li>
        </ul>
      </li>
      <li>우선 순위 큐 (prioirty queue)
        <ul>
          <li>우선 순위에 따라 빠져나오는 큐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="문제-설명">문제 설명</h3>
<p>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.</p>

<p><code class="language-plaintext highlighter-rouge">섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)</code></p>

<p>Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.</p>

<p>Leo가 가진 음식의 스코빌 지수를 담은 배열 <code class="language-plaintext highlighter-rouge">scoville</code>과 원하는 스코빌 지수 <code class="language-plaintext highlighter-rouge">K</code>가 주어질 때, 모든 음식의 스코빌 지수를 <code class="language-plaintext highlighter-rouge">K</code> 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한-사항">제한 사항</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">scoville</code>의 길이는 1 이상 1,000,000 이하입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">K</code>는 0 이상 1,000,000,000 이하입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">scoville</code>의 원소는 각각 0 이상 1,000,000 이하입니다.</li>
  <li>모든 음식의 스코빌 지수를 <code class="language-plaintext highlighter-rouge">K</code> 이상으로 만들 수 없는 경우에는 -1을 return 합니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>
<p><img width="279" alt="스크린샷 2023-10-20 오후 6 33 37" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/bc206ae6-2db7-4788-a4bb-a8e480cd3a39" /></p>

<h3 id="방법-1">방법 1</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">scoville</code> 배열 정렬</li>
  <li>앞에서부터 공식에 따라 계산
    <ul>
      <li>(가장 작은 수) + (두번째로 작은 수 * 2)</li>
    </ul>
  </li>
  <li>계산된 결과를 배열에 삽입
    <ul>
      <li>순서에 맞게!</li>
    </ul>
  </li>
  <li>모든 원소가 7보다 클 때까지 위 과정 반복</li>
</ul>

<h4 id="알고리즘-복잡도">알고리즘 복잡도</h4>
<ul>
  <li>최악의 경우
    <ul>
      <li>수가 하나 남을 때까지 섞어야 하는 경우 (n-1 회)</li>
    </ul>
  </li>
  <li>각 단계 (섞는 일) 에서 요구되는 계산량
    <ul>
      <li>정렬된 리스트에 순서를 맞추어 원소 삽입</li>
      <li>$O(n)$</li>
    </ul>
  </li>
  <li><strong>전체 : $O(n^2)$</strong>
    <ul>
      <li>지나치게 높음</li>
      <li><strong>Heap</strong> 이용</li>
    </ul>
  </li>
</ul>

<h3 id="보다-나은-방법">보다 나은 방법</h3>
<ul>
  <li>최소/최대 원소를 빠르게 꺼내는 방법!</li>
  <li>힙 (Heap)
    <ul>
      <li>max heap</li>
      <li>min heap</li>
    </ul>
  </li>
</ul>

<h3 id="python에서-힙-적용">python에서 힙 적용</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>       <span class="c1"># 리스트 L로부터 min heap 구성 
</span><span class="n">m</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>   <span class="c1"># min heap L에서 최소값 삭제 (반환)
</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>   <span class="c1"># min heap L에 원소 x 삽입
</span></code></pre></div></div>

<h3 id="코드">코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">scoville</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># 섞은 횟수
</span>
    <span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">min1</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min1</span> <span class="o">&gt;=</span> <span class="n">K</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="nf">len</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>
        <span class="n">min2</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">scoville</span><span class="p">)</span>
        <span class="n">new_scoville</span> <span class="o">=</span> <span class="n">min1</span> <span class="o">+</span> <span class="p">(</span><span class="n">min2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">scoville</span><span class="p">,</span> <span class="n">new_scoville</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<ul>
  <li>$O(nlogn)$</li>
</ul>

<h2 id="2-dynamic-programming-대표-문제---n으로-표현">2. Dynamic Programming 대표 문제 - N으로 표현</h2>

<h3 id="동적계획법-dynamic-programming">동적계획법 (Dynamic Programming)</h3>

<ul>
  <li>문제의 답인지 확인하기 위해서 탐색해야 하는 범위(solution space)를 진전하면서 동적으로 결정
    <ul>
      <li>처음에 정해놓고 시작하는 것이 아님</li>
      <li>탐색 범위를 한정할 수 있음</li>
    </ul>
  </li>
  <li>주어진 최적화 문제를 (보통 최적화 문제를 다룸)
    <ul>
      <li>재귀적인 방식으로 보다 작은 부분 문제로 나누어</li>
      <li>부분 문제를 풀어, 이 해를 조합하여</li>
      <li>전체 문제의 해답에 이르는 방식</li>
    </ul>
  </li>
</ul>

<h4 id="적용-예시---피보나치-수열">적용 예시 - 피보나치 수열</h4>
<ul>
  <li>피보나치 수열을 재귀함수로 구현한다면?</li>
</ul>

<p><img width="243" alt="스크린샷 2023-10-21 오후 12 00 40" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/2dbfd1b1-4302-42a9-87f6-832023760ff9" /></p>

<ul>
  <li>같은 수를 여러 번 구해야 함</li>
  <li>복잡도 : 지수 함수의 형태</li>
</ul>

<p><br /></p>

<ul>
  <li>동적 계획법을 적용한다면?
    <ul>
      <li>f(0) = 0, f(1) = 1</li>
      <li>f(2) = f(1) + f(0) = 1</li>
      <li>f(3) = f(2) + f(1) = 2</li>
      <li>f(4) = f(3) + f(2) = 3</li>
    </ul>
  </li>
  <li>부분 문제의 답을 구해놓고, 그것을 이용해서 전체 문제의 답을 구하는 방식</li>
  <li>복잡도 : 선형 함수의 형태</li>
</ul>

<h4 id="적용-예시---knapsack-problem">적용 예시 - Knapsack Problem</h4>
<ul>
  <li>가장 높은 값을 가지도록 물건을 골라 배낭에 담기</li>
</ul>

<h3 id="문제-설명-1">문제 설명</h3>
<p>아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.</p>

<p>12 = 5 + 5 + (5 / 5) + (5 / 5)  <br />
12 = 55 / 5 + 5 / 5   <br />
12 = (55 + 5) / 5</p>

<p>5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.</p>

<p>이처럼 숫자 <code class="language-plaintext highlighter-rouge">N</code>과 <code class="language-plaintext highlighter-rouge">number</code>가 주어질 때, <code class="language-plaintext highlighter-rouge">N</code>과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요.</p>

<h3 id="제한-사항-1">제한 사항</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">N</code>은 1 이상 9 이하입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">number</code>는 1 이상 32,000 이하입니다.</li>
  <li>수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.</li>
  <li>최솟값이 8보다 크면 -1을 return 합니다.</li>
</ul>

<h3 id="입출력-예-1">입출력 예</h3>

<p><img width="211" alt="스크린샷 2023-10-21 오전 11 54 31" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/3181d21b-04e9-428f-88f8-d3dc8c45baf9" /></p>

<h3 id="문제-해결-방법">문제 해결 방법</h3>

<ul>
  <li>N을 한 번 사용해서 만들 수 있는 수(들) -&gt; <code class="language-plaintext highlighter-rouge">1</code></li>
  <li>N을 두 번 사용해서 만들 수 있는 수(들) -&gt; <code class="language-plaintext highlighter-rouge">2</code></li>
  <li>N을 세 번 사용해서 만들 수 있는 수(들) -&gt; <code class="language-plaintext highlighter-rouge">3</code>   <br />
…</li>
</ul>

<p>위 과정을 반복하다가 정답이 나오면 출력</p>

<h4 id="예제">예제</h4>
<ul>
  <li>N = 3</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">1</code> : 5   <br />
<code class="language-plaintext highlighter-rouge">2</code> : 55 or <code class="language-plaintext highlighter-rouge">1</code>   <code class="language-plaintext highlighter-rouge">+ - x /</code>   <code class="language-plaintext highlighter-rouge">1</code>        <br />
<code class="language-plaintext highlighter-rouge">3</code> : 555 or <code class="language-plaintext highlighter-rouge">1</code>   <code class="language-plaintext highlighter-rouge">+ - x /</code>   <code class="language-plaintext highlighter-rouge">2</code>  <br />
     555 or <code class="language-plaintext highlighter-rouge">2</code>   <code class="language-plaintext highlighter-rouge">+ - x /</code>   <code class="language-plaintext highlighter-rouge">1</code></p>

<p><img width="618" alt="스크린샷 2023-10-21 오후 12 25 59" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/3ce60551-a8bd-43cd-a8f1-581e78e95cb4" /></p>

<p><br /></p>

<ul>
  <li>N = x</li>
</ul>

<p><img width="682" alt="스크린샷 2023-10-21 오후 12 27 17" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/0858b227-2a18-4888-965f-099c569b8047" /></p>

<h3 id="코드-1">코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="nf">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span>          <span class="c1"># 초기화
</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">op1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">op2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">add</span><span class="p">(</span><span class="n">op1</span> <span class="o">//</span> <span class="n">op2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">break</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<h2 id="3-깊이너비-우선-탐색-dfsbfs-대표-문제---여행경로">3. 깊이/너비 우선 탐색 (DFS/BFS) 대표 문제 - 여행경로</h2>

<h3 id="깊이-우선-탐색-dfs">깊이 우선 탐색 DFS</h3>
<ul>
  <li>한 정점에서 인접한 모든 (아직 방문하지 않은) 정점을 방문하되, 각 인접 정점을 기준으로 깊이 우선 탐색을 끝낸 후 다음 정점으로 진행
    <ul>
      <li>root에서 가장 왼쪽부터 아래로 쭉 진행 (세로로)</li>
    </ul>
  </li>
  <li><strong>스택</strong>을 이용하여 어느 정점에서 DFS를 하고 있는지를 기억하고 되돌아감</li>
</ul>

<h3 id="너비-우선-탐색-bfs">너비 우선 탐색 BFS</h3>
<ul>
  <li>한 정점에서 인접한 모든 (아직 방문하지 않은) 정점을 방문하고, 방문한 각 인접 정점을 기준으로 (방문한 순서에 따라) 또다시 너비 우선 탐색 진행
    <ul>
      <li>root부터 가로로 한 줄씩 탐색</li>
    </ul>
  </li>
  <li><strong>큐</strong>를 이용하여 어느 정점에서 BFS를 해야 하는지를 기록하고 진행함</li>
</ul>

<h3 id="문제-설명-2">문제 설명</h3>

<p>주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 “ICN” 공항에서 출발합니다.</p>

<p>항공권 정보가 담긴 2차원 배열 <code class="language-plaintext highlighter-rouge">tickets</code>가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한-조건">제한 조건</h3>
<ul>
  <li>모든 공항은 알파벳 대문자 3글자로 이루어집니다.</li>
  <li>주어진 공항 수는 3개 이상 10,000개 이하입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">tickets</code>의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.</li>
  <li>주어진 항공권은 모두 사용해야 합니다.</li>
  <li>만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.</li>
  <li>모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.</li>
</ul>

<h3 id="입출력-예-2">입출력 예</h3>

<p><img width="878" alt="스크린샷 2023-10-21 오후 1 19 33" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/c556fd43-24db-4d2c-855e-17fc2d846309" /></p>

<h3 id="문제-해결-방법---dfs-응용">문제 해결 방법 - DFS 응용</h3>
<ul>
  <li>한 붓 그리기!
    <ul>
      <li>이것이 가능함은 문제에서 보장되어 있음</li>
    </ul>
  </li>
  <li>시작 정점은 언제나 “ICN”</li>
  <li>모든 정점 방문이 아니고, 모든 <strong>간선</strong>을 거쳐야 함
    <ul>
      <li>언젠가는 한 번 가야하는데, 그 순서를 결정하는 것!</li>
    </ul>
  </li>
  <li>한 정점에서 택할 수 있는 간선이 두 개 이상인 경우
    <ul>
      <li>공항 이름의 알파벳 순서를 따름</li>
    </ul>
  </li>
</ul>

<h3 id="알고리즘-설계">알고리즘 설계</h3>
<ul>
  <li>입출력 두번째 예제</li>
</ul>

<p><img width="277" alt="스크린샷 2023-10-21 오후 1 24 17" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/c2547147-d49d-49bc-8c56-7188e4552e8a" /></p>

<ul>
  <li>스택을 이용하여 재귀적인 <strong>한 붓 그리기</strong> 문제 해결
    <ul>
      <li>DFS 알고리즘의 응용</li>
    </ul>
  </li>
</ul>

<h3 id="코드-2">코드</h3>

<h4 id="그래프의-표현">그래프의 표현</h4>
<ul>
  <li>사전을 이용하여 각 공항에서 출발하는 항공권의 <strong>리스트</strong>을 표현
    <ul>
      <li>경로가 여러 개 일 경우 알파벳 순으로 방문해야 함 -&gt; 리스트 이용</li>
      <li>리스트: 뒤에서 제거하는 것이 편함
        <ul>
          <li>알파벳의 <strong>역순</strong>으로 정렬</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ICN -&gt; [SFO, ATL]</code>    <br />
<code class="language-plaintext highlighter-rouge">ATL -&gt; [SFO, ICN]</code>    <br />
<code class="language-plaintext highlighter-rouge">SFO -&gt; [ATL]</code></p>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">tickets</span><span class="p">):</span>
    <span class="n">routes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tickets</span><span class="p">:</span>
        <span class="n">routes</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">routes</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">:</span>
        <span class="n">routes</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="nf">sort</span><span class="p">(</span><span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
    
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">ICN</span><span class="sh">"</span><span class="p">]</span>  <span class="c1"># 출발은 항상 ICN
</span>    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">top</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">routes</span> <span class="ow">or</span> <span class="nf">len</span><span class="p">(</span><span class="n">routes</span><span class="p">[</span><span class="n">top</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">routes</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">routes</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">routes</span><span class="p">[</span><span class="n">top</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># pop도 가능
</span>    
    <span class="k">return</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># 리스트 역순으로 출력
</span></code></pre></div></div>

<h3 id="알고리즘-복잡도-1">알고리즘 복잡도</h3>
<ul>
  <li>스택에 들어가고 나오는 횟수 : 한번씩 들어가고 꺼내짐
    <ul>
      <li>ticket의 개수에 비례</li>
    </ul>
  </li>
  <li>표에 해당하는 공항에 대해 조사할 때 : list의 맨 끝을 꺼냄
    <ul>
      <li>정렬을 수행했음 -&gt; $O(nlogn)$</li>
      <li>while문 반복 횟수 : ticket 개수
        <ul>
          <li>각 단계는 상수 시간</li>
          <li>$O(n)$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>전체 알고리즘 복잡도는 정렬 시간에 지배됨!
    <ul>
      <li>**$O(nlogn)$</li>
    </ul>
  </li>
</ul>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. Heap 대표 문제 - 더 맵게]]></summary></entry><entry><title type="html">[DEV] ChatGPT 활용하기</title><link href="http://localhost:4000/data%20engineering/2023/10/20/gpt.html" rel="alternate" type="text/html" title="[DEV] ChatGPT 활용하기" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-21T02:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/20/gpt</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/20/gpt.html"><![CDATA[<h2 id="1-language-model">1. Language Model</h2>

<ul>
  <li>문장의 일부를 보고 비어있는 단어를 확률적으로 맞추는 모델</li>
</ul>

<h3 id="llm">LLM</h3>

<ul>
  <li>Large Language Model</li>
  <li>GPT에서 Temperature의 개념
    <ul>
      <li>0과 100 사이의 값</li>
      <li>100에 가까울수록 조금 더 random해짐</li>
    </ul>
  </li>
</ul>

<h2 id="2-language-model-훈련">2. Language Model 훈련</h2>

<ul>
  <li>웹 상에서 존재하는 문서들이 훈련 데이터가 됨
    <ul>
      <li>품질이 중요!</li>
      <li>위키피디아, Github 등이 있음</li>
      <li>Unsupervised learning
        <ul>
          <li>문장을 하나 주면 거기서 다양한 훈련 데이터들이 만들어지는 것</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Context window의 크기가 결국 모델의 메모리를 결정</li>
</ul>

<h2 id="3-word-to-vector">3. Word to Vector</h2>

<ul>
  <li>언어 모델에 사용되는 Transformer 모델은 기본적으로 수학 모델</li>
  <li>단어를 그대로 사용할 수 없고, 이를 숫자로 변환한 후 (One-Hot Encoding) 다시 N차원 공간의 벡터로 변환
    <ul>
      <li>이를 워드 임베딩 (word embedding)이라고 부름</li>
      <li>데이터의 크기를 줄이고 단어 간의 유사도 측정 가능</li>
    </ul>
  </li>
</ul>

<h2 id="4-gpt">4. GPT</h2>
<ul>
  <li>Generative Pre-trained Transformer</li>
  <li>OpenAI에서 만든 초거대 언어 모델
    <ul>
      <li>훈련과 예측에 전용 HW 사용</li>
    </ul>
  </li>
  <li>두 가지 모델 제공
    <ul>
      <li>Word Completion
        <ul>
          <li>한국어를 포함한 다양한 언어 지원</li>
        </ul>
      </li>
      <li>Code Completion</li>
    </ul>
  </li>
</ul>

<h3 id="gpt-3-vs-gpt-4">GPT 3 vs. GPT 4</h3>
<ul>
  <li>GPT-3
    <ul>
      <li>175B 파라미터 = 800GB</li>
      <li>Context window 크기는 2,048 + 1</li>
      <li>12,288 개의 워드 벡터 사용</li>
    </ul>
  </li>
  <li>GPT-4
    <ul>
      <li>1T 파라미터</li>
      <li>Context window 크기는 8,192 + 1</li>
      <li>32,768 개의 워드 벡터 사용</li>
      <li>Multi-modal (이미지 인식)</li>
    </ul>
  </li>
  <li>경량 모델들도 나오기 시작
    <ul>
      <li>메타의 LLaMA</li>
      <li>스탠포드의 Alpaca
        <ul>
          <li>LLaMA의 파인튜닝 버전</li>
        </ul>
      </li>
      <li>데이터브릭스의 Dolly</li>
    </ul>
  </li>
</ul>

<h3 id="gpt-api">GPT API</h3>
<ul>
  <li>GPT API
    <ul>
      <li>Completion
        <ul>
          <li>word</li>
          <li>code</li>
        </ul>
      </li>
      <li>Fine-tuning</li>
    </ul>
  </li>
  <li>Whisperer API
    <ul>
      <li>text to speech</li>
      <li>speech to text</li>
    </ul>
  </li>
  <li>ChatGPT API
    <ul>
      <li>대화형 GPT</li>
    </ul>
  </li>
  <li>모두 유료!</li>
</ul>

<h2 id="5-fine-tuning">5. Fine-tuning</h2>
<ul>
  <li>이미 만들어진 모델 (Pre-trained Model) 위에 새로운 레이어를 얹히고 다른 용도의 데이터로 훈련하는 것</li>
  <li>GPT는 이를 API로 지원함
    <ul>
      <li>기본 언어 모델 위에 나만의 모델 생성 (버티컬 전용 모델)</li>
    </ul>
  </li>
</ul>

<h2 id="6-chatgpt">6. ChatGPT</h2>
<ul>
  <li>GPT를 챗봇의 형태로 Fine-tuning
    <ul>
      <li>RLHF : Reinforcement Learning from Human Feedback</li>
      <li>GPT의 지식을 챗봇의 형태로 활용 가능
        <ul>
          <li>Prompts 엔지니어링 탄생</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="rlhf">RLHF</h3>
<ul>
  <li>사람 피드백을 기반으로 대화하는 인공지능 모델 학습</li>
  <li>사람이 선호하는 응답을 평가하는 인공지능 모델 학습</li>
  <li>강화학습 기법을 활용해 ChatGPT 학습</li>
</ul>

<h3 id="chatgpt-40">ChatGPT 4.0</h3>
<ul>
  <li>월 20$</li>
  <li>Code Interpreter 추가
    <ul>
      <li>코드를 작성하고 주피터 노트북에서 실행 가능</li>
      <li>샘플 데이터를 업로드하고 관련해서 다양한 질문 가능</li>
    </ul>
  </li>
  <li>인터넷을 통해 연결하고 일부 정보를 검색</li>
  <li>이미지 업로드 지원
    <ul>
      <li>이미지 기반으로 질문 가능</li>
    </ul>
  </li>
  <li>플러그인 기능 추가
    <ul>
      <li>ex) 여행 리서치 + 예약까지</li>
      <li>사용/개발 시 별도 등록 필요</li>
      <li>기본 4.0 써도 OFF 되어있음 -&gt; 설정에서 켜야 함</li>
    </ul>
  </li>
</ul>

<h2 id="7-chatgpt-활용법">7. ChatGPT 활용법</h2>
<ul>
  <li>동반자로 생각하고 친해져라! 나를 위한 Digital Assistant</li>
  <li><strong>모든</strong> 일에 ChatGPT 사용해보기
    <ul>
      <li>Prompt 작성 연습</li>
    </ul>
  </li>
  <li>코딩에서 사용해보기
    <ul>
      <li>특정 기능의 함수를 구현해야 하는 경우
        <ul>
          <li>파라미터 설명해주고 테스트 케이스까지 제공해주면 금상첨화</li>
          <li>잘못된 답이 나올 수 있기 때문에 테스트 케이스의 작성이 중요</li>
          <li>틀린 답이 나온 경우 테스트 케이스를 바탕으로 재작성 요구</li>
        </ul>
      </li>
      <li>내 코드 리뷰 요구</li>
      <li>내 코드에 주석 추가</li>
      <li>내 코드에 테스트 코드 추가 요구</li>
      <li>Github Copilot</li>
    </ul>
  </li>
</ul>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="특강" /><category term="KDT" /><summary type="html"><![CDATA[1. Language Model]]></summary></entry><entry><title type="html">[DEV] 1주차. 자료구조/알고리즘(4)</title><link href="http://localhost:4000/data%20engineering/2023/10/19/1019.html" rel="alternate" type="text/html" title="[DEV] 1주차. 자료구조/알고리즘(4)" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-20T02:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/19/1019</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/19/1019.html"><![CDATA[<h2 id="1-hash-대표-문제---완주하지-못한-선수">1. Hash 대표 문제 - 완주하지 못한 선수</h2>

<h3 id="해시-문제">해시 문제</h3>
<p>이름과 그에 따른 횟수를 기록하는 경우</p>

<h3 id="문제-설명">문제 설명</h3>

<p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p>

<p>마라톤에 참여한 선수들의 이름이 담긴 배열 <code class="language-plaintext highlighter-rouge">participant</code>와 완주한 선수들의 이름이 담긴 배열 <code class="language-plaintext highlighter-rouge">completion</code>이 주어질 때, 완주하지 못한 선수의 이름을 return하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한-사항">제한 사항</h3>

<ul>
  <li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">completion</code>의 길이는 <code class="language-plaintext highlighter-rouge">participant</code>의 길이보다 1 작습니다.</li>
  <li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
  <li>참가자 중에는 <strong>동명이인</strong>이 있을 수 있습니다.
    <ul>
      <li>차집합으로 구할 수 없게 됨!</li>
    </ul>
  </li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<p><img width="578" alt="스크린샷 2023-10-19 오후 3 53 36" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/16ae80e3-71e0-4c21-89fc-5d74e8a9aa57" /></p>

<h3 id="문제의-풀이">문제의 풀이</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">participant</code> 의 이름과 이름이 등장한 횟수를 hash table에 저장</li>
  <li><code class="language-plaintext highlighter-rouge">completion</code> 에서 나온 이름들은 있는 개수만큼 뺄셈</li>
  <li>
    <p>마지막에 hash table에 개수가 남아있는 이름 반환</p>
  </li>
  <li>python dictionary 사용!!</li>
  <li>사전의 원소들을 해시를 이용해 $O(1)$ 시간에 접근 가능</li>
</ul>

<h3 id="코드">코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">participant</span><span class="p">,</span> <span class="n">completion</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">participant</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># x가 존재하면 그 키에 해당하는 값을, 없으면 0 return
</span>    
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">completion</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">dnf</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">dnf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<h3 id="알고리즘-복잡도">알고리즘 복잡도</h3>

<ul>
  <li>3-4행, 5-6행 for문 2개
    <ul>
      <li><code class="language-plaintext highlighter-rouge">participant</code>, <code class="language-plaintext highlighter-rouge">completion</code> 배열의 길이에 비례</li>
    </ul>
  </li>
  <li>7행 for문
    <ul>
      <li>사전 <code class="language-plaintext highlighter-rouge">d</code>의 크기에 비례</li>
      <li>사전의 크기는 <code class="language-plaintext highlighter-rouge">participant</code> 크기에 비례함</li>
    </ul>
  </li>
  <li>함수 전체의 시간 복잡도
    <ul>
      <li><code class="language-plaintext highlighter-rouge">participant</code> 배열의 길이에 비례하는 <strong>linear time</strong> 알고리즘</li>
      <li>hash table을 key를 기준으로 상수 시간으로 읽고 쓸 수 있었기 때문!</li>
    </ul>
  </li>
</ul>

<h3 id="다른-풀이">다른 풀이</h3>

<ul>
  <li><strong>정렬</strong> 을 이용!
    <ul>
      <li>알파벳 순 정렬</li>
      <li><code class="language-plaintext highlighter-rouge">participant</code>에는 있고, <code class="language-plaintext highlighter-rouge">completion</code>에는 없는 원소 찾기</li>
      <li>앞에서부터 하나씩 비교</li>
      <li>정렬의 최소 시간이 $O(nlogn)$ 이기 때문에 위의 풀이가 더 나음!</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="2-greedy-대표-문제---체육복">2. Greedy 대표 문제 - 체육복</h2>

<h3 id="greedy-algorithm">Greedy Algorithm</h3>

<p>알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택</p>

<p>현재의 선택이 마지막 해답의 최적성을 해치지 않을 경우 Greedy Algorithm으로 최적해를 찾을 수 있음</p>

<h3 id="문제-설명-1">문제 설명</h3>

<p>점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.</p>

<p>전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 <code class="language-plaintext highlighter-rouge">lost</code>, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 <code class="language-plaintext highlighter-rouge">reserve</code>가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한-사항-1">제한 사항</h3>

<ul>
  <li>전체 학생의 수는 2명 이상 30명 이하입니다.</li>
  <li>체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li>
  <li>여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li>
  <li>여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.</li>
  <li>여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.</li>
</ul>

<h3 id="입출력-예-1">입출력 예</h3>

<p><img width="275" alt="스크린샷 2023-10-19 오후 11 31 59" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/e875acb0-ae49-40b6-9b43-b09cb61123a0" /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<ul>
  <li>빌려줄 학생들을 <strong>정해진 순서</strong>로 살펴야 하고, 이 <strong>정해진 순서</strong>에 따라 우선하여 빌려줄 방향을 정해야 함</li>
</ul>

<h4 id="방법-1">방법 1</h4>

<ul>
  <li>착안점) 학생의 수는 기껏해야 30!</li>
  <li>학생 수만큼 배열을 확보하고, 여기에 각자가 가지고 있는 체육복의 수 기록</li>
  <li>번호 순서대로 스캔하면서 빌려줄 관계를 정함</li>
</ul>

<h5 id="알고리즘-복잡도-1">알고리즘 복잡도</h5>

<ul>
  <li>여벌을 가져온 학생 처리 : <code class="language-plaintext highlighter-rouge">reverse</code>의 길이에 비례</li>
  <li>체육복을 잃어버린 학생 처리 : <code class="language-plaintext highlighter-rouge">lost</code>의 길이에 비례</li>
  <li>체육복 빌려주기 처리 : 전체 학생 수 (n)에 비례</li>
  <li><strong>전체 : $O(n)$ (linear time)</strong></li>
</ul>

<h4 id="방법-2">방법 2</h4>

<ul>
  <li>만약 전체 학생 수가 매우 크다면?</li>
  <li>문제의 성질 상 $O(n)$ 보다 낮은 복잡도 알고리즘은 어려울 듯</li>
  <li>
    <p>그러나, 여벌의 체육복을 가져온 학생은 매우 적다면?</p>
  </li>
  <li>여벌의 체육복을 가져온 학생들의 번호 <code class="language-plaintext highlighter-rouge">reverse</code>를 정렬하고,</li>
  <li>이것을 하나하나 순서대로 살펴보면서 빌려줄 수 있는 다른 학생을 찾아서 처리</li>
</ul>

<h5 id="알고리즘-복잡도-2">알고리즘 복잡도</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">reverse</code> 정렬 : $O(klogk)$</li>
  <li>빌려줄 수 있는 다른 학생 처리 : 해시를 적용해서 상수 시간에 처리 $O(k) x O(1) = O(k)$</li>
  <li>전체 : $O(klogk)$</li>
  <li><code class="language-plaintext highlighter-rouge">reverse</code>와 <code class="language-plaintext highlighter-rouge">lost</code> 배열 길이의 차이가 매우 클 경우에 유용</li>
</ul>

<h3 id="방법-1-코드">방법 1 코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lost</span><span class="p">,</span> <span class="n">reverse</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 1번 보다 앞, n번보다 뒤
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lost</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="nf">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="방법-2-코드">방법 2 코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lost</span><span class="p">,</span> <span class="n">reverse</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">lost</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nf">set</span><span class="p">(</span><span class="n">reserve</span><span class="p">)</span>  <span class="c1"># 도난 당했지만, 빌릴 필요가 없는 학생들
</span>    <span class="n">l</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">lost</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span>   <span class="c1"># 도난 당했고, 빌려야 하는 학생들
</span>    <span class="n">r</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">reserve</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span>   <span class="c1"># 여분의 체육복이 남은 학생들
</span>    
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">l</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="k">elif</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">l</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># l에 남아있는 학생들: 빌려야 하는데 빌리지 못한 학생들
</span>    <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="3-정렬-대표-문제---가장-큰-수">3. 정렬 대표 문제 - 가장 큰 수</h2>

<h3 id="문제-설명-2">문제 설명</h3>

<p>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</p>

<p>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</p>

<p>0 또는 양의 정수가 담긴 배열 <code class="language-plaintext highlighter-rouge">numbers</code>가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한-사항-2">제한 사항</h3>

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.</li>
</ul>

<h3 id="입출력-예-2">입출력 예</h3>

<p><img width="241" alt="스크린샷 2023-10-20 오전 12 46 33" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/80efef45-b9f4-4466-9056-a2f332a04dbe" /></p>

<h3 id="방법-1-1">방법 1</h3>

<ul>
  <li>빈 문자열로 수 초기화</li>
  <li>가장 크게 만들 수 있는 수 고름</li>
  <li>그 수를 현재 수에 이어 붙임</li>
  <li>
    <p>모든 수를 다 사용할 때까지 반복</p>
  </li>
  <li>복잡도 : 목록의 길이의 제곱에 비례 $O(n^2)$</li>
</ul>

<h3 id="방법-2-더-나음">방법 2 (더 나음)</h3>

<ul>
  <li>빈 문자열로 수 초기화</li>
  <li>수의 목록을 (<strong>크게 만드는 것 우선으로</strong>) 정렬</li>
  <li>목록에서 하나씩 꺼내어 현재 수에 이어 붙임</li>
  <li>
    <p>모든 수를 다 사용할 때까지 반복</p>
  </li>
  <li>복잡도 : 정렬 $O(nlogn)$</li>
</ul>

<h4 id="알고리즘-설계">알고리즘 설계</h4>

<ul>
  <li>대소 관계 비교를 위한 기준 마련</li>
  <li>그것을 이용하여 주어진 배열 정렬</li>
  <li>정렬된 배열을 이용하여 문자열 표현 완성</li>
</ul>

<h3 id="코드-1">코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
    <span class="n">numbers</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)[:</span><span class="mi">4</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>

<h3 id="알고리즘-복잡도-3">알고리즘 복잡도</h3>
<ul>
  <li>2행 : $O(n)$</li>
  <li>3행 (정렬) : $O(nlogn)$</li>
  <li>4-5행 : $O(1)$</li>
  <li>6-7행 : $O(n)$</li>
  <li><strong>전체 : $O(nlogn)$</strong></li>
</ul>

<p><br /></p>

<h2 id="4-greedy-대표-문제---큰-수-만들기">4. Greedy 대표 문제 - 큰 수 만들기</h2>

<h3 id="문제-설명-3">문제 설명</h3>

<p>어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.</p>

<p>문자열 형식으로 숫자 <code class="language-plaintext highlighter-rouge">number</code>와 제거할 수의 개수 <code class="language-plaintext highlighter-rouge">k</code>가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</p>

<h3 id="제한-조건">제한 조건</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">number</code>는 2자리 이상, 1,000,000자리 이하인 숫자입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">k</code>는 1 이상 number의 자릿수 미만인 자연수입니다.</li>
</ul>

<h3 id="입출력-예-3">입출력 예</h3>

<p><img width="278" alt="스크린샷 2023-10-20 오후 4 02 13" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/1767ac0e-8fb2-44a9-98db-fe07362ebb94" /></p>

<h3 id="큰-수-만들기">큰 수 만들기</h3>

<ul>
  <li>앞 자리에 큰 수가 오는 것이 전체를 크게 만듦
    <ul>
      <li>큰 것을 우선해서 골라 담기!</li>
    </ul>
  </li>
  <li>앞 자리에서부터 하나씩 골라 담되, 지금 담으려는 것보다 작은 것들은 도로 뺌
    <ul>
      <li>뺄 수 있는 개수에 도달할 때까지만 (<code class="language-plaintext highlighter-rouge">k</code>)</li>
    </ul>
  </li>
  <li>큰 수가 앞자리에, 작은 수가 뒷자리에 놓이도록
    <ul>
      <li>제약조건 : 뺄 수 있는 수의 개수</li>
    </ul>
  </li>
</ul>

<h3 id="알고리즘-설계-1">알고리즘 설계</h3>

<ul>
  <li>주어진 숫자 <code class="language-plaintext highlighter-rouge">number</code>로부터 하나씩 꺼내어 모으되
    <ul>
      <li>이미 모아둔 것 중 지금 등장한 것보다 작은 것들은 빼냄
        <ul>
          <li>오른쪽부터 왼쪽으로 살펴봄</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이렇게 모은 숫자들을 자릿수 맞추어 반환
    <ul>
      <li>아직 뺄 개수(<code class="language-plaintext highlighter-rouge">k</code>)를 채우지 못한 경우
        <ul>
          <li>자릿수 계산!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="알고리즘-복잡도-4">알고리즘 복잡도</h3>

<ul>
  <li>가장 단순한 방법: 모든 경우의 수를 계산해서 비교
    <ul>
      <li>매우 복잡</li>
    </ul>
  </li>
  <li>위에서 설계한 알고리즘 복잡도 : $O(n)$</li>
</ul>

<h3 id="코드-2">코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">collected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">collected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">collected</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">collected</span> <span class="o">+=</span> <span class="nf">list</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
            <span class="k">break</span>
        <span class="n">collected</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="n">collected</span> <span class="o">=</span> <span class="n">collected</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">collected</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">collected</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div></div>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. Hash 대표 문제 - 완주하지 못한 선수]]></summary></entry><entry><title type="html">[DEV] 1주차. 자료구조/알고리즘(3)</title><link href="http://localhost:4000/data%20engineering/2023/10/18/1018.html" rel="alternate" type="text/html" title="[DEV] 1주차. 자료구조/알고리즘(3)" /><published>2023-10-18T00:00:00+09:00</published><updated>2023-10-19T02:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/18/1018</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/18/1018.html"><![CDATA[<h2 id="1-queue">1. Queue</h2>

<ul>
  <li>자료를 보관할 수 있는 (선형) 구조</li>
  <li>선입선출 구조 (FIFO)
    <ul>
      <li>한 쪽 끝에서 밀어 넣는 연산: 인큐(enqueue) 연산</li>
      <li>반대 쪽에서 뽑아 꺼내는 연산: 디큐(dequeue) 연산</li>
      <li>들어간 순서와 동일한 순서로 데이터가 꺼내짐</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="2-큐의-동작">2. 큐의 동작</h2>

<ul>
  <li>빈 큐 <code class="language-plaintext highlighter-rouge">Q = Queue()</code></li>
  <li>데이터 원소 A를 큐에 추가 <code class="language-plaintext highlighter-rouge">Q.enqueue(A)</code></li>
  <li>데이터 원소 B를 큐에 추가 <code class="language-plaintext highlighter-rouge">Q.enqueue(B)</code></li>
  <li>데이터 원소 꺼내기 <code class="language-plaintext highlighter-rouge">r1 = Q.dequeue()</code>
    <ul>
      <li>r1 == A</li>
    </ul>
  </li>
  <li>데이터 원소 또 꺼내기 <code class="language-plaintext highlighter-rouge">r2 = Q.dequeue()</code>
    <ul>
      <li>r2 == B</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="3-큐의-추상적-자료구조-구현">3. 큐의 추상적 자료구조 구현</h2>

<h3 id="0-연산-정의">0) 연산 정의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">size()</code> : 현재 큐에 들어 있는 데이터 원소의 수 구함</li>
  <li><code class="language-plaintext highlighter-rouge">isEmpty()</code> : 현재 큐가 비어있는지 판단</li>
  <li><code class="language-plaintext highlighter-rouge">enqueue(x)</code> : 데이터 원소 x를 큐에 추가</li>
  <li><code class="language-plaintext highlighter-rouge">dequeue(x)</code> : 큐의 맨 앞에 저장된 데이터 원소 제거 + 반환</li>
  <li><code class="language-plaintext highlighter-rouge">peek()</code> : 큐의 맨 앞에 저장된 데이터 원소 반환 (제거하지 않음)</li>
</ul>

<h3 id="1-배열을-이용하여-구현">1) 배열을 이용하여 구현</h3>
<ul>
  <li>list</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArrayQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 0번 인덱스 pop, 뒤의 원소들은 앞으로 밀림 (1-&gt;0, 2-&gt;1)
</span>    
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="배열로-구현한-큐의-연산-복잡도">배열로 구현한 큐의 연산 복잡도</h4>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>복잡도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>size()</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>isEmpty()</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>enqueue()</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>dequeue()</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>peek()</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<h4 id="dequeue-연산">dequeue 연산</h4>
<ul>
  <li>0번 원소가 없어지고, 나머지 원소들이 앞으로 밀리기 때문</li>
  <li>큐의 길이에 비례 -&gt; 바람직하지 않음</li>
</ul>

<p><img width="512" alt="스크린샷 2023-09-18 오후 2 38 54" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/96ec6ee5-c5af-4715-b313-af9ab2a63fc6" /></p>

<h3 id="2-연결-리스트를-이용하여-구현">2) 연결 리스트를 이용하여 구현</h3>
<ul>
  <li>양방향 연결 리스트</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedListQueue</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nc">DoublyLinkedList</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">getLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">getLength</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">insertAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">popAt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">data</span>
</code></pre></div></div>

<h3 id="3-library">3) Library</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pythonds.basic.queue</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="n">Q</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>

<span class="nf">dir</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="c1"># ['__doc__', '__init__', '__module__', 'dequeue', 'enqueue', 'isEmpty', 'items', 'size']
</span></code></pre></div></div>

<p><br /></p>

<h2 id="4-큐의-활용">4. 큐의 활용</h2>

<ul>
  <li>
    <p>자료를 생성하는 작업과 그 자료를 이용하는 작업이 비동기적으로 일어나는 경우
<img width="573" alt="스크린샷 2023-09-18 오후 2 59 43" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/f7a422a6-0b7c-4b26-9690-37be671acfbf" /></p>
  </li>
  <li>
    <p>자료를 생성하는 작업이 여러 곳에서 일어나는 경우
<img width="570" alt="스크린샷 2023-09-18 오후 3 00 05" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/4c1632af-8943-4959-bbde-a020e427b991" /></p>
  </li>
  <li>
    <p>자료를 이용하는 작업이 여러 곳에서 일어나는 경우
<img width="572" alt="스크린샷 2023-09-18 오후 3 00 35" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/6a511437-58f8-45ad-afb6-790c3e851896" /></p>
  </li>
  <li>
    <p>자료를 생성하는 작업과 그 자료를 이용하는 작업이 양쪽 다 여러 곳에서 일어나는 경우
<img width="572" alt="스크린샷 2023-09-18 오후 3 01 05" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/48bf542d-d676-46ef-a95c-53cd71990965" /></p>
  </li>
  <li>
    <p>자료를 처리하여 새로운 자료를 생성하고 나중에 그 자료를 또 처리해야 하는 작업의 경우
<img width="387" alt="스크린샷 2023-09-18 오후 3 01 34" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/dfa41a2d-98f3-487c-87a2-c37ac263b36c" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="5-환형-큐-circular-queues">5. 환형 큐 (Circular Queues)</h2>

<ul>
  <li>정해진 개수의 저장 공간을 빙 돌려가며 이용</li>
  <li>큐가 가득 차면 더이상 원소를 넣을 수 없음 -&gt; 큐 길이를 기억하고 있어야 함</li>
</ul>

<p><br /></p>

<h2 id="6-환형-큐의-추상적-자료구조-구현">6. 환형 큐의 추상적 자료구조 구현</h2>

<h3 id="0-연산-정의-1">0) 연산 정의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">size()</code> : 현재 큐에 들어 있는 데이터 원소의 수 구함</li>
  <li><code class="language-plaintext highlighter-rouge">isEmpty()</code> : 현재 큐가 비어있는지 판단</li>
  <li><code class="language-plaintext highlighter-rouge">isFull()</code> : 큐에 데이터 원소가 꽉 차 있는지를 판단</li>
  <li><code class="language-plaintext highlighter-rouge">enqueue(x)</code> : 데이터 원소 x를 큐에 추가</li>
  <li><code class="language-plaintext highlighter-rouge">dequeue(x)</code> : 큐의 맨 앞에 저장된 데이터 원소 제거 + 반환</li>
  <li><code class="language-plaintext highlighter-rouge">peek()</code> : 큐의 맨 앞에 저장된 데이터 원소 반환 (제거하지 않음)</li>
</ul>

<h3 id="1-배열로-구현한-환형-큐">1) 배열로 구현한 환형 큐</h3>

<ul>
  <li>정해진 길이 n의 리스트 확보</li>
  <li><code class="language-plaintext highlighter-rouge">enQueue(x)</code> 할 때 rear += 1
    <ul>
      <li>rear는 마지막으로 추가된 원소의 인덱스</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">deQueue()</code> 할 때 front += 1
    <ul>
      <li>front는 큐에서 가장 앞에 있는 원소 (가장 먼저 들어간) 보다 하나 작은 인덱스</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># rear = A
</span><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>  <span class="c1"># rear = B
</span><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>  <span class="c1"># rear = C
</span><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>  <span class="c1"># rear = D
</span><span class="n">r1</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>  <span class="c1"># front = A, r1 = A, A는 무효한 데이터 취급
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>  <span class="c1"># front = B, r2 = B, B는 무효한 데이터 취급
</span><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>  <span class="c1"># rear = F, front는 1번 인덱스 가리키는 중
</span><span class="n">Q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># rear = G (0번 인덱스)
</span><span class="n">r3</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>  <span class="c1"># front = C, r3 = C
</span></code></pre></div></div>

<ul>
  <li>front와 rear를 적절히 계산하여 배열을 환형으로 재활용</li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CircularQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">maxCount</span> <span class="o">=</span> <span class="n">n</span>        <span class="c1"># 인자로 주어진 최대 큐 길이 설정
</span>        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">isFull</span><span class="p">(</span><span class="n">Self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">maxCount</span>

    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isFull</span><span class="p">():</span>
            <span class="k">raise</span> <span class="nc">IndexError</span><span class="p">(</span><span class="sh">'</span><span class="s">Queue full</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">maxCount</span><span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">self</span><span class="p">.</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">IndexError</span><span class="p">(</span><span class="sh">'</span><span class="s">Queue empty</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">maxCount</span><span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">self</span><span class="p">.</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">front</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="nc">IndexError</span><span class="p">(</span><span class="sh">'</span><span class="s">Queue empty</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">maxCount</span><span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">self</span><span class="p">.</span><span class="n">front</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>더 간편하게!
    <ul>
      <li><code class="language-plaintext highlighter-rouge">0 if self.front+1 &gt; self.maxCount-1 else self.front+1</code></li>
      <li><code class="language-plaintext highlighter-rouge">(self.front+1) % self.maxCount</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="7-우선순위-큐-priority-queue">7. 우선순위 큐 (Priority Queue)</h2>

<ul>
  <li>큐가 FIFO 방식을 따르지 않고, 원소들의 우선순위에 따라 큐에서 빠져나오는 방식</li>
  <li>활용
    <ul>
      <li>운영체제의 CPU 스케줄러</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="8-우선순위-큐의-구현">8. 우선순위 큐의 구현</h2>

<ul>
  <li>두 가지 방법
    <ul>
      <li>Enqueue 할 때 우선순위 순서를 유지하도록
        <ul>
          <li>더 유리!</li>
        </ul>
      </li>
      <li>Dequeue 할 때 우선순위 높은 것을 선택</li>
    </ul>
  </li>
  <li>두 가지 재료
    <ul>
      <li>선형 배열 이용</li>
      <li>연결리스트 이용
        <ul>
          <li>더 유리!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="양방향-연결-리스트">양방향 연결 리스트</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">doublylinkedlist</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">DoublyLinkedList</span>

<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="nc">DoublyLinkedList</span><span class="p">()</span>

    <span class="c1"># 작은 값이 우선순위 높음
</span>    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">newNode</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span>  <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">head</span>  <span class="c1"># 주의) getAt() 메서드 사용하지 않음
</span>        <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">tail</span> <span class="ow">and</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">newNode</span><span class="p">.</span><span class="n">data</span><span class="p">:</span>   <span class="c1"># 끝을 만나지 않고, 우선순위를 만족하는 조건
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">insertAfter</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">popAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">getLength</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="nf">getLength</span><span class="p">()).</span><span class="n">data</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">enqueue</code> while 문 조건
    <ul>
      <li><code class="language-plaintext highlighter-rouge">insertAfter</code> 이기 때문에 curr의 다음이 tail이면 멈춰서 마지막에 insert해야 함</li>
      <li>curr가 newNode보다 작다고 하면 그 작은 값보다 앞에 삽입되기 때문에 curr.next가 newNode보다 작을 때 멈춰야 함</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="9-트리">9. 트리</h2>

<ul>
  <li>
    <p>정점(node)와 간선(edge)를 이용하여 데이터의 배치 형태를 추상화한 자료 구조</p>
  </li>
  <li>노드의 수준 (level)
    <ul>
      <li>root node = 레벨 0</li>
      <li>root 노드부터 해당 노드까지 거치는 간선의 개수</li>
    </ul>
  </li>
  <li>트리의 높이/깊이 (height/depth)
    <ul>
      <li>모든 노드들 중 최대 수준(level) + 1</li>
    </ul>
  </li>
  <li>노드의 차수 (degree)
    <ul>
      <li>자식(서브트리)의 수</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="10-이진-트리-binary-tree">10. 이진 트리 (binary tree)</h2>

<ul>
  <li>모든 노드의 차수가 2 이하인 트리</li>
  <li>재귀적으로 정의할 수 있음
    <ul>
      <li>빈 트리이거나 // 루트 노드 + 왼쪽 서브트리 + 오른쪽 서브트리</li>
      <li>이때 왼쪽, 오른쪽 서브트리 또한 빈 트리 / 이진 트리</li>
    </ul>
  </li>
</ul>

<p><img width="407" alt="스크린샷 2023-09-18 오후 7 13 32" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/1b57859b-af78-4999-ae9d-a5723c294566" /></p>

<p><br /></p>

<h3 id="1-포화-이진-트리-full-binary-tree">1) 포화 이진 트리 (full binary tree)</h3>

<ul>
  <li>모든 레벨에서 노드들이 모두 채워져 있는 이진 트리</li>
  <li>높이가 $k$이고, 노드의 개수가 $2^k-1$인 이진 트리</li>
</ul>

<h3 id="2-완전-이진-트리-complete-binary-tree">2) 완전 이진 트리 (complete binary tree)</h3>

<ul>
  <li>높이가 $k$인 완전 이진 트리</li>
  <li>레벨 $k-2$까지는 모든 노드가 2개의 자식을 가진 포화 이진 트리</li>
  <li>레벨 $k-1$에서는 왼쪽부터 노드가 순차적으로 채워져 있는 이진 트리</li>
</ul>

<p><img width="234" alt="스크린샷 2023-09-18 오후 7 18 16" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/2e853215-d34a-4478-a062-4d6efbb92f82" /></p>

<p><br /></p>

<h2 id="11-이진-트리의-추상적-자료구조">11. 이진 트리의 추상적 자료구조</h2>

<h3 id="1-연산의-정의">1) 연산의 정의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">size()</code> : 현재 트리에 포함되어 있는 노드의 수 구함</li>
  <li><code class="language-plaintext highlighter-rouge">depth()</code> : 현재 트리의 깊이(높이)를 구함</li>
  <li>순회 (traversal) : 정해진 순서로 노드를 방문해서 처리하는 연산</li>
</ul>

<h3 id="2-이진-트리의-구현">2) 이진 트리의 구현</h3>

<ul>
  <li>Node
    <ul>
      <li>data</li>
      <li>left child</li>
      <li>right child</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>Tree
    <ul>
      <li>root</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>size()
    <ul>
      <li>재귀적인 방법으로 쉽게 구할 수 있음</li>
      <li>전체 이진 트리의 size    <br />
  = left subtree size() + right subtree size() + 1 (자기자신)</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># 자기 자신이 root인 서브트리의 사이즈 구하는 멤버 메소드
</span>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>depth()
    <ul>
      <li>재귀적인 방법으로 쉽게 구할 수 있음</li>
      <li>전체 이진 트리의 depth()   <br />
  = left subtree depth() + right subtree depth() 중 더 큰 것 + 1 (자기자신)</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># 자기 자신이 root인 서브트리의 사이즈 구하는 멤버 메소드
</span>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># 자기 자신을 root로 하는 서브트리의 depth
</span>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">depth</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">depth</span><span class="p">()</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">depth</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="12-이진-트리의-순회-traversal">12. 이진 트리의 순회 (traversal)</h2>

<h3 id="깊이-우선-순회-depth-first-traversal">깊이 우선 순회 (depth first traversal)</h3>

<h4 id="중위-순회-in-order">중위 순회 (in-order)</h4>

<p><img width="235" alt="스크린샷 2023-09-18 오후 8 00 08" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/046a5ade-576f-497a-8a70-4aa032a65808" /></p>

<ul>
  <li>left subtree -&gt; <strong>자기 자신</strong> -&gt; right subtree</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="c1"># 자기자신이 root인 서브트리에 대해 중위순회
</span>    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="n">traversal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">traversal</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<h4 id="전위-순회-pre-order">전위 순회 (pre-order)</h4>

<p><img width="285" alt="스크린샷 2023-09-18 오후 8 03 30" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/807cb274-7e9c-4c2e-ab55-883e70f84ccf" /></p>

<ul>
  <li><strong>자기 자신</strong> -&gt; left subtree -&gt; right subtree</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">traversal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">preorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">preorder</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">traversal</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">preorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<h4 id="후위-순회-post-order">후위 순회 (post-order)</h4>

<p><img width="306" alt="스크린샷 2023-09-18 오후 8 04 25" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/ed894da0-196d-4c3c-8ea7-e421912380af" /></p>

<ul>
  <li>left subtree -&gt; right subtree -&gt; <strong>자기 자신</strong></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">postorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">postorder</span><span class="p">()</span>
        <span class="n">traversal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">traversal</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">postorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<h3 id="넓이-우선-순회-breadth-first-traversal">넓이 우선 순회 (breadth first traversal)</h3>

<p><img width="397" alt="스크린샷 2023-09-18 오후 8 17 49" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/2da2fcc7-f0d1-43bb-bc6f-0226955ac1dc" /></p>

<p><br /></p>

<ul>
  <li>level이 낮은 노드 우선 방문 (root부터 한 줄씩 아래로)</li>
  <li>같은 레벨의 노드들 사이에는
    <ul>
      <li>부모 노드의 방문 순서에 따라 방문</li>
      <li>왼쪽 자식 노드를 오른쪽 자식보다 먼저 방문</li>
    </ul>
  </li>
  <li>이 방식에 재귀적 방법이 적합한가?
    <ul>
      <li><strong>NO</strong></li>
    </ul>
  </li>
  <li>한 노드를 방문했을 때
    <ul>
      <li>나중에 방문할 노드들을 순서대로 기록해 두어야 함</li>
      <li><strong>Queue</strong> 이용!</li>
    </ul>
  </li>
</ul>

<h4 id="알고리즘-설계">알고리즘 설계</h4>

<ul>
  <li>root 노드 -&gt; 큐에 넣고
    <ul>
      <li>꺼내면서 왼쪽 자식 -&gt; 오른쪽 자식 순서대로 enqueue</li>
      <li>dequeue 하면서 왼쪽 자식 -&gt; 오른쪽 자식 순서대로 enqueue</li>
      <li>반복!</li>
    </ul>
  </li>
  <li>(초기화) traversal &lt;- 빈 리스트, q &lt;- 빈 큐</li>
  <li>빈 트리가 아니면, root node를 q에 추가 (enqueue)</li>
  <li>q가 비어있지 않은 동안
    <ul>
      <li>node &lt;- q 에서 원소 추출 (dequeue)</li>
      <li>node 방문</li>
      <li>node의 왼쪽, 오른쪽 자식이 있다면 이들을 q에 추가</li>
    </ul>
  </li>
  <li>q가 빈 큐가 되면 모든 노드 방문 완료</li>
</ul>

<h4 id="구현">구현</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span>


    <span class="k">def</span> <span class="nf">bft</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nc">ArrayQueue</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
            <span class="n">traversal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">traversal</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">traversal</code>에 넣을 때 <code class="language-plaintext highlighter-rouge">node.data</code> !!! 로 넣어야 함!</li>
</ul>

<p><br /></p>

<h2 id="13-이진-탐색-트리-binary-search-trees">13. 이진 탐색 트리 (Binary Search Trees)</h2>

<ul>
  <li>모든 노드에 대해서
    <ul>
      <li>왼쪽 서브트리에 있는 데이터는 모두 현재 노드의 값보다 작고</li>
      <li>오른쪽 서브트리에 있는 데이터는 모두 현재 노드의 값보다 큰  <br />
  성질을 만족하는 이진 트리</li>
    </ul>
  </li>
  <li>
    <p>중복되는 데이터 원소는 없는 것으로 가정</p>
  </li>
  <li>배열을 이용한 이진 탐색과 유사한 과정</li>
</ul>

<h3 id="정렬된-배열을-이진-탐색과-비교">정렬된 배열을 이진 탐색과 비교</h3>

<ul>
  <li>장점
    <ul>
      <li>데이터 원소의 추가, 삭제가 용이</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>공간 소요가 큼</li>
      <li>왼쪽, 오른쪽 자식을 기록해 두어야 하기 때문</li>
      <li>항상 $O(logn)$의 복잡도? [no]</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="14-이진-탐색-트리의-추상적-자료-구조">14. 이진 탐색 트리의 추상적 자료 구조</h2>

<h3 id="1-데이터-표현-각-노드는-key-value의-쌍으로">1) 데이터 표현: 각 노드는 (key, value)의 쌍으로</h3>

<p><img width="266" alt="스크린샷 2023-09-18 오후 8 53 05" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/e446edfb-08f7-4c1f-863d-6b36ecc80a20" /></p>

<ul>
  <li>키를 이용해서 검색 가능</li>
  <li>보다 복잡한 데이터 레코드로 확장 가능</li>
</ul>

<h3 id="2-연산의-정의">2) 연산의 정의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">insert(key, data)</code> : 트리에 주어진 데이터 원소를 추가</li>
  <li><code class="language-plaintext highlighter-rouge">remove(key)</code> : 특정 원소를 트리로부터 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">lookup(key)</code> : 특정 원소를 검색</li>
  <li><code class="language-plaintext highlighter-rouge">inorder()</code> : 키의 순서대로 데이터 원소를 나열</li>
  <li><code class="language-plaintext highlighter-rouge">min()</code>, <code class="language-plaintext highlighter-rouge">max()</code> : 최소 키, 최대 키를 가지는 원소를 각각 탐색</li>
</ul>

<h3 id="3-초기화">3) 초기화</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="4-inorder_traversal">4) inorder_traversal()</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> 
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="n">traversal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">traversal</span>

<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">inorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<h3 id="5-min">5) min()</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span>

<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="6-max">6) max()</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span>

<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="7-lookup">7) lookup()</h3>

<ul>
  <li>입력 인자: 찾으려는 대상 키</li>
  <li>출력 인자: 찾은 노드와, 그것의 부모 노드</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">,</span> <span class="n">parent</span>

<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="8-insert">8) insert()</h3>

<ul>
  <li>입력 인자: 키, 데이터 원소</li>
  <li>출력 인자: 없음</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">KeyError</span><span class="p">(</span><span class="sh">'</span><span class="s">...</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 중복된 원소는 없다고 가정
</span>
<span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="15-노드의-삭제-remove">15. 노드의 삭제, remove()</h2>

<ul>
  <li>key를 이용해서 노드를 찾음
    <ul>
      <li>해당 키의 노드가 없으면 삭제할 것도 없음</li>
      <li>찾은 노드의 부모 노드도 알고 있어야 함</li>
    </ul>
  </li>
  <li>찾은 노드를 제거하고도 이진 탐색 트리 성질을 만족하도록 트리의 구조를 정리해야 함</li>
</ul>

<h3 id="인터페이스-설계">인터페이스 설계</h3>

<ul>
  <li>입력 인자: 키</li>
  <li>출력 인자: 삭제한 경우 <code class="language-plaintext highlighter-rouge">True</code>, 해당 키의 노드가 없는 경우 <code class="language-plaintext highlighter-rouge">False</code></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BinSearchTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parnet</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="bp">...</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h3 id="이진-탐색-트리-구조의-유지">이진 탐색 트리 구조의 유지</h3>

<p>삭제되는 노드가</p>
<ul>
  <li>말단(leaf) 노드인 경우
    <ul>
      <li>그냥 그 노드를 없애면 됨</li>
      <li>부모 노드의 링크를 조정 (좌 / 우)</li>
    </ul>
  </li>
  <li>자식을 하나 가지고 있는 경우
    <ul>
      <li>삭제되는 노드 자리에 그 자식을 대신 배치</li>
      <li>자식이 왼 / 오</li>
      <li>부모 노드의 링크를 조정 (좌 / 우)</li>
    </ul>
  </li>
  <li>자식을 둘 가지고 있는 경우
    <ul>
      <li>삭제되는 노드보다 바로 다음 (큰) 키를 가지는 노드를 찾아 그 노드를 삭제되는 노드 자리에 대신 배치하고 이 노드를 대신 삭제
        <ul>
          <li>오른쪽 서브트리에서 가장 왼쪽 키 (가장 작은) + 그 키의 부모 노드</li>
        </ul>
      </li>
      <li>(or) 바로 전 (작은) 키로 대신 배치해도 됨</li>
    </ul>
  </li>
</ul>

<h3 id="자식-개수-세기">자식 개수 세기</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countChildren</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="16-이진-탐색-트리가-별로-효율적이지-못한-경우">16. 이진 탐색 트리가 별로 효율적이지 못한 경우</h2>

<ul>
  <li>순서대로 키를 갖는 노드들을 insert -&gt; 선형 탐색과 동등한 복잡도를 갖게 됨
<img width="236" alt="스크린샷 2023-09-18 오후 10 03 32" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/ad0b526f-cd39-46d8-abbe-0b4fb619d7d2" /></li>
</ul>

<p><br /></p>

<h2 id="17-보다-나은-성능을-보이는-이진-탐색-트리들">17. 보다 나은 성능을 보이는 이진 탐색 트리들</h2>

<ul>
  <li>높이의 균형을 유지함으로써 $O(logn)$의 탐색 복잡도 보장</li>
  <li>삽입, 삭제 연산이 보다 복잡함</li>
  <li>AVL tree, Red-black tree</li>
</ul>

<p><br /></p>

<h2 id="18-힙-heaps">18. 힙 (Heaps)</h2>

<ul>
  <li>이진 트리의 한 종류 (이진 힙 binary heap)</li>
  <li>조건
    <ul>
      <li>root 노드가 언제나 최댓값 / 최솟값을 가짐
        <ul>
          <li>최대 힙(max heap) / 최소 힙(min heap)</li>
          <li>특정한 노드에서 봤을 때 자신의 자식들보다 항상 크거나 작아야 함</li>
        </ul>
      </li>
      <li>완전 이진트리여야 함</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>최대 힙의 예
<img width="270" alt="스크린샷 2023-09-18 오후 11 01 01" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/c4e430dc-cfb1-48dd-82c6-52f08a4c2f28" /></p>
  </li>
  <li>재귀적으로도 정의됨</li>
  <li>어느 노드를 루트로 하는 서브트리도 모두 최대 힙</li>
</ul>

<p><br /></p>

<h2 id="19-이진-탐색-트리와의-비교">19. 이진 탐색 트리와의 비교</h2>

<table>
  <thead>
    <tr>
      <th>비교</th>
      <th>이진 탐색 트리</th>
      <th>힙</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>원소들은 완전히 크기 순으로 정렬되어 있는가?</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>특정 키 값을 가지는 원소를 빠르게 검색할 수 있는가?</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>부가의 제약 조건은 어떤 것인가?|</td>
      <td>완전 이진 트리여야 함</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="20-최대-힙의-추상적-자료구조">20. 최대 힙의 추상적 자료구조</h2>

<h3 id="1-연산의-정의-1">1) 연산의 정의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">__init__()</code> : 빈 최대 힙 생성</li>
  <li><code class="language-plaintext highlighter-rouge">insert(item)</code> : 새로운 원소 삽입</li>
  <li><code class="language-plaintext highlighter-rouge">remove()</code> : 최대 원소 (root node) 반환 + 해당 노드 삭제</li>
</ul>

<h3 id="2-배열을-이용한-이진-트리의-표현">2) 배열을 이용한 이진 트리의 표현</h3>

<p><img width="190" alt="스크린샷 2023-09-18 오후 11 08 02" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/a6e55c73-a6f2-46a7-93b0-796d338bd49b" /></p>

<p><img width="399" alt="스크린샷 2023-09-18 오후 11 09 42" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/4a858801-2373-406d-8cb7-b05db77934ac" /></p>

<ul>
  <li>노드 번호 m을 기준으로
    <ul>
      <li>왼쪽 자식의 번호: <code class="language-plaintext highlighter-rouge">2 * m</code></li>
      <li>오른쪽 자식의 번호 : <code class="language-plaintext highlighter-rouge">2 * m + 1</code></li>
      <li>부모 노드의 번호 : <code class="language-plaintext highlighter-rouge">m // 2</code></li>
    </ul>
  </li>
  <li><strong>완전 이진 트리</strong>이므로 노드의 추가/삭제는 마지막 노드에서만 일어남 <br />
-&gt; 배열로 표현하기 나쁘지 않음</li>
</ul>

<h3 id="3-초기화-1">3) 초기화</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MaxHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>  <span class="c1"># 0번 인덱스는 버림
</span></code></pre></div></div>

<h3 id="4-최대-힙에-원소-삽입">4) 최대 힙에 원소 삽입</h3>

<ul>
  <li>트리의 마지막 자리에 새로운 원소를 임시로 저장</li>
  <li>
    <p>부모 노드와 키 값을 비교하여 위로, 위로 이동</p>
  </li>
  <li>복잡도
    <ul>
      <li>원소의 개수가 $n$인 최대 힙에 새로운 원소 삽입</li>
      <li>부모 노드와의 대소 비교 최대 횟수: $log_2^n$</li>
      <li>최악 복잡도 $O(logn)$의 삽입 연산</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MaxHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
</code></pre></div></div>

<ul>
  <li><strong>부모 노드와</strong> 비교 해야 함 -&gt; <code class="language-plaintext highlighter-rouge">i//2</code> 와 비교!</li>
</ul>

<p><br /></p>

<h3 id="5-최대-힙에서-원소의-삭제">5) 최대 힙에서 원소의 삭제</h3>

<ul>
  <li>항상 최댓값이 삭제 -&gt; 루트 노드의 제거</li>
  <li>트리 마지막 자리 노드를 임시로 루트 노드의 자리에 배치 -&gt; <strong>완전 이진 트리</strong></li>
  <li>자식 노드들과의 값 비교하여 아래로, 아래로 이동 -&gt; <strong>최대 힙</strong>
    <ul>
      <li>자식은 두 개일 수 있음</li>
      <li>둘 중 더 큰 값을 기준으로 !</li>
    </ul>
  </li>
  <li>복잡도
    <ul>
      <li>원소의 개수가 $n$인 최대 힙에서 최대 원소 삭제</li>
      <li>자식 노드들과의 대소 비교 최대 횟수: $2 * log_2^n$</li>
      <li>최악 복잡도 $O(logn)$의 삭제 연산</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MaxHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">maxHeapify</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># root 노드부터, 최대 힙 구조 유지
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">maxHeapify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">greatest</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># 자신(i), left, right 중 최대 -&gt; 인덱스를 greatest에 담음
</span>        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">greatest</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">greatest</span><span class="p">]:</span>
            <span class="n">greatest</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">greatest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">greatest</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">greatest</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">maxHeapify</span><span class="p">(</span><span class="n">greatest</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>i, left, right 중 최댓값을 변수에 담을 때 <code class="language-plaintext highlighter-rouge">elif</code>가 아니라 <code class="language-plaintext highlighter-rouge">if</code> <br />
-&gt; left와 i를 먼저 비교하고, 그 중 최댓값과 right 를 비교하는 것</li>
</ul>

<p><br /></p>

<h2 id="21-최대최소-힙의-응용">21. 최대/최소 힙의 응용</h2>

<ul>
  <li>우선 순위 큐
    <ul>
      <li>enqueue 할 때 ‘느슨한 정렬’을 이루고 있도록 함 : $O(logn)$</li>
      <li>dequeue 할 때 최댓값을 순서대로 추출 : $O(logn)$</li>
    </ul>
  </li>
  <li>힙 정렬
    <ul>
      <li>정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입 : $O(logn)$</li>
      <li>삽입이 끝나면, 힙이 비게 될 때까지 하나씩 삭제 : $O(logn)$</li>
      <li>원소들이 삭제된 순서가 원소들의 정렬 순서</li>
      <li>정렬 알고리즘의 복잡도 : $O(nlogn)$</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="힙-정렬-코드-구현">힙 정렬 코드 구현</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">unsorted</span><span class="p">):</span>
    <span class="n">H</span> <span class="o">=</span> <span class="nc">MaxHeap</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">unsorted</span><span class="p">:</span>
        <span class="n">H</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="nb">sorted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="nf">remove</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">d</span><span class="p">:</span>
        <span class="nb">sorted</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="nf">remove</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">sorted</span>
</code></pre></div></div>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. Queue]]></summary></entry><entry><title type="html">[DEV] 1주차. 자료구조/알고리즘(2)</title><link href="http://localhost:4000/data%20engineering/2023/10/17/1017.html" rel="alternate" type="text/html" title="[DEV] 1주차. 자료구조/알고리즘(2)" /><published>2023-10-17T00:00:00+09:00</published><updated>2023-10-18T02:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/17/1017</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/17/1017.html"><![CDATA[<h2 id="1-연결-리스트-linked-lists">1. 연결 리스트 Linked Lists</h2>

<h3 id="추상적-자료구조">추상적 자료구조</h3>

<ul>
  <li>
    <p>자료구조의 내부 구현은 숨겨두고, data와 연산의 집합만 보여주는 자료구조</p>
  </li>
  <li>data
    <ul>
      <li>ex) 정수, 문자열, 레코드, …</li>
    </ul>
  </li>
  <li>A set of operations
    <ul>
      <li>삽입, 삭제, 순회, …</li>
      <li>정렬, 탐색, …</li>
    </ul>
  </li>
</ul>

<h3 id="기본적-연결-리스트">기본적 연결 리스트</h3>

<p><img width="888" alt="스크린샷 2023-09-13 오후 11 17 23" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/0462a164-731d-47c9-a21a-2dc89cfc1112" /></p>

<ul>
  <li>Node
    <ul>
      <li>data
        <ul>
          <li>문자열, 레코드, 다른 연결 리스트 등이 올 수 있음</li>
        </ul>
      </li>
      <li>link (next)</li>
    </ul>
  </li>
  <li>추상적 자료구조를 만들기 위해 2개의 클래스 생성</li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 비어있는 연결 리스트
</span><span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="2-배열-vs-연결리스트">2. 배열 vs. 연결리스트</h2>

<table>
  <thead>
    <tr>
      <th>|</th>
      <th>배열</th>
      <th>연결 리스트</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>저장 공간</td>
      <td>연속한 위치</td>
      <td>임의의 위치</td>
    </tr>
    <tr>
      <td> </td>
      <td>특정 원소 지칭</td>
      <td>매우 간편</td>
      <td>선형 탐색과 유사</td>
    </tr>
    <tr>
      <td> </td>
      <td>특정 원소 지칭할 때</td>
      <td>O(1)</td>
      <td>O(n)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="3-연산-정의">3. 연산 정의</h2>

<ul>
  <li>특정 원소 참조 (k번째)</li>
  <li>리스트 순회</li>
  <li>길이 얻어내기</li>
  <li>원소 삽입</li>
  <li>원소 삭제</li>
  <li>두 리스트 합치기</li>
</ul>

<h3 id="1-특정-원소-참조-k번째">1) 특정 원소 참조 (k번째)</h3>

<p><img width="917" alt="스크린샷 2023-09-14 오전 2 11 50" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/b2507c34-1b96-4efc-8158-3db4873aabbc" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># LinkedList 클래스의 함수
</span><span class="k">def</span> <span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">curr</span>
</code></pre></div></div>

<h3 id="2-리스트-순회">2) 리스트 순회</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">now</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">lst</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="n">lst</span>
</code></pre></div></div>

<h3 id="3-길이-얻어내기">3) 길이 얻어내기</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">self.nodeCount</code> 출력</li>
</ul>

<h3 id="4-원소-삽입">4) 원소 삽입</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">newNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 맨 끝에 삽입할 경우 -&gt; tail이 prev
</span>        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  
            <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="c1"># 나머지 경우 -&gt; getAt 메서드 사용
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">newNode</span>

    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">newNode</span>

    <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<ul>
  <li>원소 삽입 복잡도
    <ul>
      <li>맨 앞에 삽입하는 경우: $O(1)$</li>
      <li>중간에 삽입하는 경우: $O(n)$</li>
      <li>맨 끝에 삽입하는 경우: $O(1)$</li>
    </ul>
  </li>
</ul>

<h3 id="5-원소-삭제">5) 원소 삭제</h3>

<ul>
  <li>주의사항
    <ul>
      <li>삭제하려는 노드가 맨 앞의 것일 때
        <ul>
          <li>prev 없음</li>
          <li>head 조정 필요</li>
        </ul>
      </li>
      <li>리스트 맨 끝의 노드 삭제할 때
        <ul>
          <li>tail 조정 필요</li>
          <li>prev를 찾을 방법이 없기 때문에 tail로 한 번에 처리할 수 없음</li>
        </ul>
      </li>
      <li>유일한 노드를 삭제할 때?</li>
    </ul>
  </li>
  <li>원소 삽입 복잡도
    <ul>
      <li>맨 앞에 삽입하는 경우: $O(1)$</li>
      <li>중간에 삽입하는 경우: $O(n)$</li>
      <li>맨 끝에 삽입하는 경우: $O(n)$</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">popAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
            
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">data</span>
</code></pre></div></div>

<h3 id="6-두-리스트의-연결">6) 두 리스트의 연결</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>

</code></pre></div></div>

<h2 id="4-연결리스트-클래스-코드">4. 연결리스트 클래스 코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">'</span><span class="s">LinkedList: empty</span><span class="sh">'</span>

        <span class="n">s</span> <span class="o">=</span> <span class="sh">''</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nf">repr</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sh">'</span><span class="s"> -&gt; </span><span class="sh">'</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">s</span>


    <span class="k">def</span> <span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">curr</span>


    <span class="k">def</span> <span class="nf">insertAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">newNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">newNode</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">newNode</span>

        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">True</span>


    <span class="k">def</span> <span class="nf">getLength</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span>


    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">.</span><span class="n">tail</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">tail</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="n">L</span><span class="p">.</span><span class="n">nodeCount</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="5-조금-변형된-연결리스트">5. 조금 변형된 연결리스트</h2>

<ul>
  <li>맨 앞에 dummy node 추가
    <ul>
      <li>데이터가 없는 노드</li>
      <li>기존 연결리스트는 맨 앞에 원소를 삽입하거나 삭제하는 연산을 지정하기 애매함</li>
    </ul>
  </li>
  <li>새로운 메서드 추가
    <ul>
      <li><code class="language-plaintext highlighter-rouge">reverse(self)</code></li>
      <li><code class="language-plaintext highlighter-rouge">insertAfter(prev, newNode)</code></li>
      <li><code class="language-plaintext highlighter-rouge">popAfter(prev)</code></li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
		<span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
		<span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
		<span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># dummy node
</span>		<span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
		<span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>


	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="sh">'</span><span class="s">LinkedList: empty</span><span class="sh">'</span>

		<span class="n">s</span> <span class="o">=</span> <span class="sh">''</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
		<span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
			<span class="n">s</span> <span class="o">+=</span> <span class="nf">repr</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="sh">'</span><span class="s"> -&gt; </span><span class="sh">'</span>
		<span class="k">return</span> <span class="n">s</span>


	<span class="k">def</span> <span class="nf">getLength</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span>


	<span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
		<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
		<span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
			<span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="n">prev</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


	<span class="k">def</span> <span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">None</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
		<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">:</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

		<span class="k">return</span> <span class="n">curr</span>


	<span class="k">def</span> <span class="nf">insertAfter</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">newNode</span><span class="p">):</span>
		<span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
		<span class="k">if</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">newNode</span>
		<span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">newNode</span>
		<span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="bp">True</span>


	<span class="k">def</span> <span class="nf">insertAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">newNode</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">False</span>

		<span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">insertAfter</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">popAfter</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>   
        <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">data</span>
        

    <span class="k">def</span> <span class="nf">popAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">popAfter</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>                                                

	<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
		<span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
		<span class="k">if</span> <span class="n">L</span><span class="p">.</span><span class="n">tail</span><span class="p">:</span>
			<span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">tail</span>
		<span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="n">L</span><span class="p">.</span><span class="n">nodeCount</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="6-doubly-linked-list">6. Doubly Linked List</h2>

<ul>
  <li>한 쪽으로만 링크를 연결하지 말고, 양쪽으로 연결하자!</li>
  <li>앞으로도 (next node) 뒤로도 (previous node) 진행 가능</li>
</ul>

<p><img width="630" alt="스크린샷 2023-09-14 오후 2 03 01" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/98150bb4-21e5-4b50-9699-eaa4bf04eb28" /></p>

<ul>
  <li>노드에 <code class="language-plaintext highlighter-rouge">prev</code> 추가</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>리스트 처음과 끝에 dummy node 생성
    <ul>
      <li>-&gt; 데이터를 담고 있는 노드들은 모두 같은 모양</li>
      <li>코드 작성이 편안해짐</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DoublyLinkedList</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p><img width="383" alt="스크린샷 2023-09-14 오후 2 25 42" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/b7fcef0d-c936-43ea-8629-79f14128518f" /></p>

<p><br /></p>

<h2 id="7-연산-정의">7. 연산 정의</h2>

<h3 id="1-리스트-순회">1) 리스트 순회</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="역순회">역순회</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="n">prev</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h3 id="2-원소-삽입">2) 원소 삽입</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertAfter</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">newNode</span><span class="p">):</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
    <span class="n">newNode</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span>
    <span class="n">newNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
    <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">newNode</span>
    <span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">newNode</span>
    <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h3 id="3-특정-원소-얻어내기">3) 특정 원소 얻어내기</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>  <span class="n">pos</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># pos가 리스트의 뒤쪽에 있을 경우
</span>    <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">-</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">prev</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">curr</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="8-스택">8. 스택</h2>

<ul>
  <li>자료를 보관할 수 있는 (선형) 구조</li>
  <li>후입선출 (LIFO)
    <ul>
      <li>밀어 넣는: push 연산</li>
      <li>같은 쪽에서 뽑아 꺼내는: pop 연산</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="9-스택의-추상적-자료구조-구현">9. 스택의 추상적 자료구조 구현</h2>

<h3 id="1-배열을-이용하여-구현">1) 배열을 이용하여 구현</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArrayStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>    <span class="c1"># 꺼내지는 않고, 맨 끝의 원소 반환
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-연결리스트를-이용하여-구현">2) 연결리스트를 이용하여 구현</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">doublylinkedlist</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="n">doublylinkedlist</span> <span class="kn">import</span> <span class="n">DoublyLinkedList</span>

<span class="k">class</span> <span class="nc">LinkedListStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nc">DoublyLinkedList</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">getLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">insertAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">popAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">getAt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">size</span><span class="p">()).</span><span class="n">data</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="10-스택-라이브러리">10. 스택 라이브러리</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pythonds.basic.stack</span> <span class="kn">import</span> <span class="n">Stack</span>
<span class="n">S</span> <span class="o">=</span> <span class="nc">Stack</span><span class="p">()</span>

<span class="nf">dir</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="c1"># ['__doc__', '__init__', '__module__', 'isEmpty', 'items', 'peek', 'pop', 'push', ...]
</span></code></pre></div></div>

<p><br /></p>

<h2 id="11-중위-표기법과-후위-표기법">11. 중위 표기법과 후위 표기법</h2>

<ul>
  <li>중위 표기법: 연산자가 피연산자들의 사이에 위치
    <ul>
      <li>(A + B) * (C + D)</li>
      <li>      1     3      2</li>
    </ul>
  </li>
  <li>후위 표기법: 연산자가 피연산자들의 뒤에 위치
    <ul>
      <li>연산자 나온 순서대로 계산 가능</li>
      <li>
        <p>괄호 필요 없음</p>
      </li>
      <li>A B + C D + *</li>
      <li>       1         2 3</li>
    </ul>
  </li>
</ul>

<h3 id="중위-표현식---후위-표현식">중위 표현식 -&gt; 후위 표현식</h3>

<p>[A * B + C] -&gt; [A B * C +]</p>

<p>[A + B * C] -&gt; [A B C * +]</p>

<p><br /></p>

<h2 id="12-알고리즘">12. 알고리즘</h2>

<h3 id="괄호가-없는-경우">괄호가 없는 경우</h3>

<ul>
  <li>피연산자 -&gt; 그대로 후위 표현식에 적음</li>
  <li>연산자 -&gt; 스택에 넣음
    <ul>
      <li>스택이 비어있지 않으면 해당 연산자와 스택의 꼭대기 원소와 우선순위 비교</li>
      <li>스택에 있던 원소가 우선순위 높거나 같은 경우
        <ul>
          <li>pop -&gt; 후위 표현식에 적음</li>
          <li>나머지 연산자는 push</li>
        </ul>
      </li>
      <li>표현식에서 나온 연산자가 스택의 꼭대기 원소보다 우선순위 높은 경우
        <ul>
          <li>그대로 push</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>수식의 끝 -&gt; 스택에서 연산자 pop해서 후위 표현식에 적음</li>
</ul>

<p><br /></p>

<h3 id="괄호가-있는-경우">괄호가 있는 경우</h3>

<ul>
  <li>여는 괄호는 스택에 push</li>
  <li>닫는 괄호를 만나면, 여는 괄호가 나올 때까지 pop</li>
  <li>연산자를 만났을 때, 여는 괄호 너머까지 pop하지 않도록
    <ul>
      <li>여는 괄호의 우선순위는 <strong>가장 낮게</strong> 설정</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="13-알고리즘-설계">13. 알고리즘 설계</h2>

<h3 id="1-연산자-우선순위-설정">1) 연산자 우선순위 설정</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-연산">2) 연산</h3>

<ul>
  <li>왼쪽부터 한글자씩 읽음</li>
  <li>피연산자이면 그냥 출력</li>
  <li>’(‘이면 스택에 push</li>
  <li>’)’이면 ‘(‘이 나올 때까지 스택에서 pop, 출력</li>
  <li>연산자이면 스택에서 이보다 높거나 같은 우선순위 것들을 pop, 출력
    <ul>
      <li>그리고 이 연산자는 스택에 push</li>
    </ul>
  </li>
  <li>스택에 남아있는 연산자는 모두 pop, 출력</li>
</ul>

<p><br /></p>

<h2 id="14-후위-표기-수식-계산">14. 후위 표기 수식 계산</h2>

<ul>
  <li>후위 표현식을 왼쪽부터 한 글자씩 읽어서</li>
  <li><strong>피연산자</strong>이면 스택에 push</li>
  <li><strong>연산자</strong>를 만나면 스택에서 <strong>pop</strong> <code class="language-plaintext highlighter-rouge">(1)</code> , 또 pop <code class="language-plaintext highlighter-rouge">(2)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(2)</code> 연산 <code class="language-plaintext highlighter-rouge">(1)</code> 계산 -&gt; 이 결과를 스택에 push</li>
      <li>뺄셈 / 나눗셈 -&gt; 피연산자 순서 주의!</li>
    </ul>
  </li>
  <li>수식의 끝에 도달하면 스택에서 pop =&gt; 계산 결과</li>
</ul>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 문자열로 들어온 숫자를 수와 연산자로 분리하여 list로
</span><span class="k">def</span> <span class="nf">splitTokens</span><span class="p">(</span><span class="n">exprStr</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">valProcessing</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">exprStr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">=</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="sh">'</span><span class="s">0123456789</span><span class="sh">'</span><span class="p">:</span>   <span class="c1"># 피연산자
</span>            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nf">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">valProcessing</span> <span class="o">=</span> <span class="bp">True</span>    <span class="c1"># 10진수 처리중
</span>        <span class="k">else</span><span class="p">:</span>    
            <span class="k">if</span> <span class="n">valProcessing</span><span class="p">:</span>   <span class="c1"># 10진수 표현이 끝난 것 -&gt; tokens에 추가
</span>                <span class="n">tokens</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">valProcessing</span> <span class="o">=</span> <span class="bp">False</span>   <span class="c1"># 10진수 처리중 X
</span>            <span class="n">tokens</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># 연산자 tokens에 추가
</span>    <span class="k">if</span> <span class="n">valProcessing</span><span class="p">:</span>
        <span class="n">tokens</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tokens</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 중위표기 -&gt; 후위표기
</span><span class="kn">from</span> <span class="n">stacks</span> <span class="kn">import</span> <span class="n">ArrayStack</span> <span class="k">as</span> <span class="n">Stack</span>

<span class="k">def</span> <span class="nf">infixToPostfix</span><span class="p">(</span><span class="n">tokenList</span><span class="p">):</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> 
        <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">=</span><span class="sh">'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span><span class="mi">1</span>
    <span class="p">}</span>

    <span class="n">opStack</span> <span class="o">=</span> <span class="nc">Stack</span><span class="p">()</span>
    <span class="n">postfixList</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">postfixList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">opStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">opStack</span><span class="p">.</span><span class="nf">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">postfixList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">opStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
            <span class="n">opStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opStack</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
                <span class="n">opStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">prec</span><span class="p">[</span><span class="n">opStack</span><span class="p">.</span><span class="nf">peek</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">[</span><span class="n">token</span><span class="p">]:</span>
                    <span class="n">postfixList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">opStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">opStack</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
                        <span class="k">break</span>
                <span class="n">opStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">opStack</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
        <span class="n">postfixList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">opStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">postfixList</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 후위 표현 수식 계산
</span><span class="kn">from</span> <span class="n">stacks</span> <span class="kn">import</span> <span class="n">ArrayStack</span> <span class="k">as</span> <span class="n">Stack</span>

<span class="k">def</span> <span class="nf">postfixEval</span><span class="p">(</span><span class="n">tokenList</span><span class="p">):</span>
    <span class="n">valStack</span> <span class="o">=</span> <span class="nc">Stack</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">valStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">valStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">valStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">valStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">valStack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">valStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="nf">splitTokens</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">postfix</span> <span class="o">=</span> <span class="nf">infixToPostfix</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nf">postfixEval</span><span class="p">(</span><span class="n">postfix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. 연결 리스트 Linked Lists]]></summary></entry><entry><title type="html">[DEV] 1주차. 자료구조/알고리즘(1)</title><link href="http://localhost:4000/data%20engineering/2023/10/16/1016.html" rel="alternate" type="text/html" title="[DEV] 1주차. 자료구조/알고리즘(1)" /><published>2023-10-16T00:00:00+09:00</published><updated>2023-10-17T02:00:00+09:00</updated><id>http://localhost:4000/data%20engineering/2023/10/16/1016</id><content type="html" xml:base="http://localhost:4000/data%20engineering/2023/10/16/1016.html"><![CDATA[<h2 id="1-파이썬-데이터타입과-알고리즘">1. 파이썬 데이터타입과 알고리즘</h2>

<h3 id="데이터타입">데이터타입</h3>
<ul>
  <li>문자열 (str) : “string”</li>
  <li>리스트 (list) : [5, 2, 3,7]</li>
  <li>사전 (dict) : {“A” : 45, “B” : 3}</li>
  <li>순서쌍 (tuple), 집합 (set), ..</li>
</ul>

<p><br /></p>

<ul>
  <li>데이터타입이 있음에도 <strong>자료구조</strong>를 알아야 하는 이유
    <ul>
      <li>기본적인 데이터타입으로 해결할 수 없는, 해결하기 어려운, 또는 자료구조로 더 효율적으로 해결할 수 있는 문제들이 있기 때문!</li>
    </ul>
  </li>
  <li>ex) 최댓값 찾기</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">Number of elements: </span><span class="sh">"</span><span class="p">))</span>
<span class="n">haystack</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Searching for the maximum value...</span><span class="sh">"</span><span class="p">)</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">haystack</span><span class="p">)</span>
<span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ts</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Maximum element = %d, Elapsed time = %.2f</span><span class="sh">"</span> <span class="o">%</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="알고리즘">알고리즘</h3>
<ul>
  <li>주어진 문제의 해결을 위한 자료구조와 연산 방법에 대한 선택</li>
  <li>해결하고자 하는 문제에 따라 최적의 해법은 서로 다름!</li>
  <li>이 선택을 하기 위해 자료구조를 이해해야 함</li>
</ul>

<p><br /></p>

<h2 id="2-선형-배열">2. 선형 배열</h2>

<ul>
  <li>파이썬의 list
    <ul>
      <li>0부터 시작</li>
      <li>원소들의 데이터타입 상관없음</li>
      <li><code class="language-plaintext highlighter-rouge">l = ['Bob', 'Cat', 1, [3, 6]]</code></li>
    </ul>
  </li>
</ul>

<h3 id="list-연산">list 연산</h3>

<h4 id="리스트의-길이와-무관-상수-시간--o1">리스트의 길이와 무관 (상수 시간) : <strong>$O(1)$</strong></h4>
<ul>
  <li>원소 덧붙이기 <code class="language-plaintext highlighter-rouge">l.append('New')</code></li>
  <li>끝에서 꺼내기 <code class="language-plaintext highlighter-rouge">l.pop()</code> -&gt; ‘New’</li>
</ul>

<h4 id="리스트의-길이에-비례-선형-시간--on">리스트의 길이에 비례 (선형 시간) : <strong>$O(n)$</strong></h4>
<ul>
  <li>L = [20, 37, 58, 72, 91]</li>
  <li><strong>원소 삽입</strong> <code class="language-plaintext highlighter-rouge">L.insert(3, 65)</code>
    <ul>
      <li>index 3의 위치에 원소 65 삽입</li>
      <li>L = [20, 37, 58, 65, 72, 91]</li>
      <li>원소를 삽입하고, 뒤의 원소들을 한 칸씩 오른쪽으로 옮기는 원리</li>
    </ul>
  </li>
  <li><strong>원소 삭제</strong> <code class="language-plaintext highlighter-rouge">del(L[2])</code>
    <ul>
      <li>index 2 위치 원소 삭제 (58)</li>
      <li>L = [20, 37, 65, 72, 91]</li>
      <li>원소를 삭제하고, 뒤의 원소들을 한 칸씩 앞으로 당기는 원리</li>
    </ul>
  </li>
  <li>del(L[2]) vs. L.pop(2)
    <ul>
      <li>del은 원소 삭제만</li>
      <li>pop은 삭제 후 삭제한 원소 반환</li>
    </ul>
  </li>
  <li><strong>원소 탐색</strong> <code class="language-plaintext highlighter-rouge">L.index(72)</code>
    <ul>
      <li>72라는 원소의 인덱스 번호 반환 (3)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="3-정렬">3. 정렬</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sorted()</code>
    <ul>
      <li>내장 함수</li>
      <li>정렬된 새로운 리스트를 얻어냄</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sort()</code>
    <ul>
      <li>리스트의 메서드</li>
      <li>해당 리스트를 정렬함 (리스트 변경)</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="n">L2</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="c1"># L2 = [2, 3, 6, 7, 8, 9, 10]
# L = [3, 8, 2, 7, 6, 10, 9]
</span>

<span class="n">L</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1"># L = [2, 3, 6, 7, 8, 9, 10]
</span></code></pre></div></div>

<p><br /></p>

<ul>
  <li>
    <p>반대로 정렬 : <code class="language-plaintext highlighter-rouge">reverse = True</code></p>
  </li>
  <li>문자열로 이루어진 리스트: 알파벳 순서를 따름 &amp; 대문자 &gt; 소문자</li>
  <li>문자열 길이로 정렬하려면 정렬에 이용하는 <strong>key</strong> 지정</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">abcd</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">xyz</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">spam</span><span class="sh">'</span><span class="p">]</span>

<span class="nf">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># ['xyz', 'abcd', 'spam']
</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">spam</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">xyz</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">abcd</span><span class="sh">'</span><span class="p">]</span>
<span class="c1"># ['xyz', 'spam', 'abcd']
# 길이가 같을 경우 상대적인 순서는 바뀌지 않음
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L</span> <span class="o">=</span> <span class="p">[{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">score</span><span class="sh">'</span><span class="p">:</span><span class="mi">83</span><span class="p">},</span>
     <span class="p">{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">Paul</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">score</span><span class="sh">'</span><span class="p">:</span><span class="mi">92</span><span class="p">}]</span>

<span class="n">L</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="sh">'</span><span class="s">score</span><span class="sh">'</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="c1"># L = [{'name':'Paul', 'score':92},
#      {'name':'John', 'score':83}]
# 점수가 높은 순으로 정렬
</span></code></pre></div></div>

<p><br /></p>

<h2 id="4-탐색">4. 탐색</h2>

<h3 id="선형-탐색-linear-search">선형 탐색 (Linear Search)</h3>

<ul>
  <li>
    <p>앞에서부터 하나씩 순차적으로 비교하는 방법</p>
  </li>
  <li>리스트의 길이에 비례하는 시간 소요 -&gt; $O(n)$</li>
  <li>최악의 경우 모든 원소를 다 비교해 보아야 함</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">linear_search</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h3 id="이진-탐색-binary-search">이진 탐색 (Binary Search)</h3>

<ul>
  <li>리스트가 이미 정렬되어 있는 경우에만 적용 가능</li>
  <li>크기 순으로 정렬되어 있다는 성질 이용</li>
  <li>
    <p>중간값과 찾으려는 값을 비교하여 리스트의 길이를 절반으로 줄여나가는 방법</p>
  </li>
  <li>한 번 비교가 일어날 때마다 리스트 반 씩 줄임 (divide &amp; conquer) -&gt; $O(logn)$</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">+</span> <span class="n">upper</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="k">while</span> <span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">+</span> <span class="n">upper</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">L</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">L</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">mid</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nf">solution</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">solution</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="5-재귀-알고리즘">5. 재귀 알고리즘</h2>
<ul>
  <li>재귀 함수 (recursive functions)
    <ul>
      <li>하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>ex) 이진 트리 (binary trees)
    <ul>
      <li>어떤 노드를 기준으로 왼쪽 서브트리의 원소들은 모두 작거나 같을 것</li>
      <li>오른쪽 서브트리의 원소들은 모두 클 것</li>
      <li>이 원칙을 모든 노드에 대해 재귀적으로 적용!</li>
    </ul>
  </li>
  <li>ex) 자연수의 합 구하기
    <ul>
      <li>1부터 n까지 모든 자연수의 합 구하기</li>
      <li>$S = \sum_{k=1}^{n} k$   -&gt;   $S = n + \sum_{k=1}^{n-1} k$
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">n</span>
  <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="nf">sum</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li><strong>중요! 종결조건을 반드시 명시해야 함</strong></li>
    </ul>
  </li>
</ul>

<h3 id="재귀-알고리즘의-효율">재귀 알고리즘의 효율</h3>
<ul>
  <li>모든 재귀 알고리즘은 반복문으로 변경 가능</li>
  <li>복잡도 측면
    <ul>
      <li>Recursive version: $O(n)$</li>
      <li>Iterative version: $O(n)$</li>
    </ul>
  </li>
  <li>효율성 측면
    <ul>
      <li>Recursive version은 n의 크기에 따라 함수를 호출하고 return하는 부가적인 작업이 필요</li>
      <li>효율성은 Iterative version이 더 뛰어남</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>ex) 피보나치 순열
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">x</span>
      <span class="k">return</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>ex) 조합의 수 계산
    <ul>
      <li>n개의 서로 다른 원소에서 m개를 택하는 경우의 수</li>
      <li>$nCm = \frac{n!}{m!(n-m)!}$</li>
      <li>재귀적이지 않은 방법
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="n">factorial</span> <span class="k">as</span> <span class="n">f</span>

  <span class="k">def</span> <span class="nf">combi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
      <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">))</span>
</code></pre></div>        </div>
      </li>
      <li>재귀적인 방법
        <ul>
          <li>$nCm = (n-1)Cm + (n-1)C(m-1)$
            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">combi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="nf">combi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="nf">combi</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
          <li>효율성 측면에서는 떨어짐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="재귀-알고리즘의-유용성">재귀 알고리즘의 유용성</h3>
<ul>
  <li>사람이 생각하는 방식을 그대로 코드로 옮길 수 있음</li>
</ul>

<p><br /></p>

<h2 id="6-알고리즘의-복잡도">6. 알고리즘의 복잡도</h2>
<ul>
  <li>시간 복잡도
    <ul>
      <li>문제의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계</li>
    </ul>
  </li>
  <li>공간 복잡도
    <ul>
      <li>문제의 크기와 이를 해결하는 데 필요한 메모리 공간 사이의 관계</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>평균 시간 복잡도 (ATC)
    <ul>
      <li>임의의 입력 패턴을 가정했을 때 소요되는 시간의 평균</li>
    </ul>
  </li>
  <li>최악 시간 복잡도 (WTC)
    <ul>
      <li>가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간</li>
    </ul>
  </li>
</ul>

<h3 id="big-o-notation">Big-O Notation</h3>
<ul>
  <li>점근 표기법의 하나</li>
  <li>어떤 함수의 증가 양상을 다른 함수와의 비교로 표현</li>
  <li>
    <p>$O(logn), O(n), O(n^2), O(2^n)$ 등으로 표기</p>
  </li>
  <li>입력의 크기가 n일 때
    <ul>
      <li>$O(logn)$ : 입력의 크기의 로그에 비례하는 시간 소요</li>
      <li>$O(n)$ : 입력의 크기에 비례하는 시간 소요</li>
    </ul>
  </li>
  <li><strong>입력의 크기</strong>가 커짐에 따라 얼마나 실행 시간이 증가하는가</li>
  <li>계수는 그다지 중요하지 않음</li>
</ul>

<h3 id="선형-시간-알고리즘-on">선형 시간 알고리즘 $O(n)$</h3>
<ul>
  <li>ex) 무작위로 배치된 수에서 최댓값을 찾기 위한 선형 탐색 알고리즘
    <ul>
      <li>끝까지 다 살펴보기 전까지는 알 수 없음</li>
      <li>Average case: $O(n)$</li>
      <li>Worst case: $O(n)$</li>
    </ul>
  </li>
</ul>

<h3 id="로그-시간-알고리즘-ologn">로그 시간 알고리즘 $O(logn)$</h3>
<ul>
  <li>ex) 크기 순으로 정렬된 수에서 특정 값을 찾기 위한 이진 탐색 알고리즘
<img width="329" alt="스크린샷 2023-10-16 오후 3 02 50" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/acdbc68f-dc64-4552-9989-b0a412235646" /></li>
</ul>

<h3 id="이차-시간-알고리즘-on2">이차 시간 알고리즘 $O(n^2)$</h3>
<ul>
  <li>ex) 삽입 정렬 (insertion sort)
<img width="310" alt="스크린샷 2023-10-16 오후 3 03 30" src="https://github.com/bokyung124/Algorithm_Exercise/assets/53086873/17a5d5d4-b7c7-4aab-b39c-3cbcf645669c" />
    <ul>
      <li>Best case: $O(n)$</li>
      <li>Worst case: $O(n^2)$</li>
    </ul>
  </li>
</ul>

<h3 id="보다-낮은-복잡도를-갖는-정렬-알고리즘">보다 낮은 복잡도를 갖는 정렬 알고리즘</h3>
<ul>
  <li>정렬 문제에 대해 $O(nlogn)$ 보다 낮은 복잡도를 갖는 알고리즘은 존재할 수 없음이 증명되어 있음</li>
  <li>ex) 병합 정렬 (merge sort)
    <ul>
      <li>$O(nlogn)$</li>
      <li>정렬할 데이터를 반씩 나누어 각각을 정렬시킴</li>
    </ul>
  </li>
</ul>]]></content><author><name>BoKyung</name></author><category term="Data Engineering" /><category term="DevCourse" /><category term="TIL" /><category term="DE" /><category term="KDT" /><summary type="html"><![CDATA[1. 파이썬 데이터타입과 알고리즘]]></summary></entry><entry><title type="html">MAC 하둡 설치</title><link href="http://localhost:4000/hadoop/2023/09/22/install-hadoop.html" rel="alternate" type="text/html" title="MAC 하둡 설치" /><published>2023-09-22T00:00:00+09:00</published><updated>2023-09-23T04:20:00+09:00</updated><id>http://localhost:4000/hadoop/2023/09/22/install-hadoop</id><content type="html" xml:base="http://localhost:4000/hadoop/2023/09/22/install-hadoop.html"><![CDATA[<h2 id="1-homebrew로-하둡-설치">1. Homebrew로 하둡 설치</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>hadoop

brew info hadoop
<span class="c"># 하둡 설치 위치</span>
<span class="c">## /opt/homebrew/Cellar/hadoop/3.3.6</span>
<span class="c">## Required: openjdk@11</span>
</code></pre></div></div>

<h3 id="hadoop-환경변수-설정">HADOOP 환경변수 설정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.bash_profile

<span class="nb">export </span><span class="nv">HADOOP_HOME</span><span class="o">=</span>/opt/homebrew/Cellar/hadoop/3.3.6/libexec  <span class="c"># 추가</span>
<span class="nb">export </span><span class="nv">HADOOP_INSTALL</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>
<span class="nb">export </span><span class="nv">HADOOP_MAPRED_HOME</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>
<span class="nb">export </span><span class="nv">HADOOP_COMMON_HOME</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>
<span class="nb">export </span><span class="nv">HADOOP_HDFS_HOME</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>
<span class="nb">export </span><span class="nv">YARN_HOME</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>
<span class="nb">export </span><span class="nv">HADOOP_COMMON_LIB_NATIVE_DIR</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>/lib/native
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$HADOOP_HOME</span>/sbin:<span class="nv">$HADOOP_HOME</span>/bin
<span class="nb">export </span><span class="nv">HADOOP_OPTS</span><span class="o">=</span><span class="s2">"-Djava.library.path=</span><span class="nv">$HADOOP_HOME</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$HADOOP_HOME</span>/lib/native
 
<span class="nb">source</span> ~/.bash_profile  <span class="c"># 적용</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="2-java_home-path---java-180_371-설정">2. JAVA_HOME PATH -&gt; java 1.8.0_371 설정</h2>

<!-- ```bash
vi ~/.bash_profile

export JAVA_HOME=/opt/homebrew/Cellar/openjdk@11/11.0.19/libexec/openjdk.jdk/Contents/Home
export PATH=$PATH:$JAVA_HOME/bin

source ~/.bash_profile 
```
```bash
java -version
# openjdk version "11.0.19" 2023-04-18
``` -->

<p><a href="https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions">https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions</a></p>

<ul>
  <li>Java 8 설치 권장</li>
</ul>

<!-- ```bash
brew install cask

brew tap AdoptOpenJDK/openjdk
brew install --cask adoptopenjdk8

java -version
# java version "1.8.0_371"
``` -->

<p><br /></p>

<h3 id="jdk-버전-변경">JDK 버전 변경</h3>

<ul>
  <li>설치된 JDK 버전 확인</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/libexec/java_home <span class="nt">-V</span>

<span class="c"># Matching Java Virtual Machines (5):</span>
<span class="c">#     17.0.7 (arm64) "Oracle Corporation" - "Java SE 17.0.7" /Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home</span>
<span class="c">#     1.8.371.11 (x86_64) "Oracle Corporation" - "Java" /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span>
<span class="c">#     1.8.0_371 (x86_64) "Oracle Corporation" - "Java SE 8" /Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home</span>
<span class="c">#     1.8.0_292 (x86_64) "AdoptOpenJDK" - "AdoptOpenJDK 8" /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home</span>
<span class="c"># /Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home

java <span class="nt">-version</span>
<span class="c"># openjdk version "1.8.0_371"</span>

<span class="nb">echo</span> <span class="nv">$JAVA_HOME</span>
<span class="c"># /Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">~/.bash_profile</code> 파일에도 JAVA_HOME 추가</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.bash_profile

<span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home  <span class="c"># 추가</span>

<span class="nb">source</span> ~/.bash_profile  <span class="c"># 적용</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="3-hadoop-환경-설정">3. Hadoop 환경 설정</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HADOOP_HOME</span>/etc/hadoop
</code></pre></div></div>

<p><br /></p>

<h3 id="1-core-sitexml">1) core-site.xml</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>fs.defaultFS<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>hdfs://localhost:9000<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>hadoop.tmp.dir<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>/tmp/hadoop-${user.name}<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-hdfs-stiexml">2) hdfs-stie.xml</h3>

<ul>
  <li>namenode, datanode 파일 만들어질 <code class="language-plaintext highlighter-rouge">/Users/{user.name}/hadoop</code> 폴더 만들어놓고 작성</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.replication<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>1<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.namenode.name.dir<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>/Users/bokyung/hadoop/namenode<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.datanode.data.dir<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>/Users/bokyung/hadoop/datanode<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.namenode.http-address<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>localhost:50070<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.namenode.secondary.http-address<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>localhost:50090<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.datanode.address<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>localhost:50010<span class="nt">&lt;/value&gt;</span>
   <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>dfs.datanode.http.address<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>localhost:50075<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="3-mapred-sitexml">3) mapred-site.xml</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>mapreduce.framework.name<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>yarn<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>mapreduce.application.classpath<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-yarn-sitexml">4) yarn-site.xml</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>yarn.nodemanager.aux-services<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>mapreduce_shuffle<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property&gt;</span>
        <span class="nt">&lt;name&gt;</span>yarn.nodemanager.env-whitelist<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;value&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-hadoop-envsh">5) hadoop-env.sh</h3>

<ul>
  <li>JAVA PATH만 한 번 더 적어주기</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/opt/homebrew/Cellar/openjdk@11/11.0.19/libexec/openjdk.jdk/Contents/Home
</code></pre></div></div>

<p><br /></p>

<h2 id="4-namenode-format">4. namenode format</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hdfs namenode <span class="nt">-format</span>
</code></pre></div></div>

<h3 id="주의할-점">주의할 점!</h3>

<ul>
  <li>환경 설정을 바꿀 때 hadoop, yarn 종료 후 변경하기
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cd $HADOOP_HOME/sbin</code> -&gt; <code class="language-plaintext highlighter-rouge">stop-yarn.sh</code> <code class="language-plaintext highlighter-rouge">stop-dfs.sh</code></li>
    </ul>
  </li>
  <li>변경 후 namenode 포맷 후 재실행</li>
  <li>포맷 전에 <strong>datanode, namenode 폴더 지우고</strong> 포맷!!!
    <ul>
      <li>그렇지 않으면 datanode가 실행되지 않음!</li>
      <li><code class="language-plaintext highlighter-rouge">hdfs-site.xml</code>에서 설정한 폴더</li>
      <li>재실행 시 다시 생김</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="5-hadoop-실행">5. Hadoop 실행</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HADOOP_HOME</span>/sbin
start-dfs.sh
start-yarn.sh

jps
<span class="c"># 98658 Jps</span>
<span class="c"># 98034 DataNode</span>
<span class="c"># 98549 NodeManager</span>
<span class="c"># 97924 NameNode</span>
<span class="c"># 98452 ResourceManager</span>
<span class="c"># 98170 SecondaryNameNode</span>
</code></pre></div></div>]]></content><author><name>BoKyung</name></author><category term="Hadoop" /><category term="Hadoop" /><category term="설치" /><summary type="html"><![CDATA[Hadoop 설치]]></summary></entry><entry><title type="html">[pilot] Ch5. 빅데이터 적재 이론 (2)</title><link href="http://localhost:4000/hadoop/2023/09/22/ch5.html" rel="alternate" type="text/html" title="[pilot] Ch5. 빅데이터 적재 이론 (2)" /><published>2023-09-22T00:00:00+09:00</published><updated>2023-09-23T05:20:00+09:00</updated><id>http://localhost:4000/hadoop/2023/09/22/ch5</id><content type="html" xml:base="http://localhost:4000/hadoop/2023/09/22/ch5.html"><![CDATA[<p>[출처: 실무로 배우는 빅데이터 기술, 김강원 저]</p>

<p><br /></p>

<h2 id="1-빅데이터-실시간-적재-개요">1. 빅데이터 실시간 적재 개요</h2>

<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/1.jpg" alt="" /></p>

<ul>
  <li>앞장에 이어서 이번에는 스마트카 운전자의 실시간 운행 정보를 분석한 후 적재하는 영역 다룸</li>
  <li><strong>실시간 로그 분석</strong>에는 작지만 대량으로 발생하는 메시지성 데이터를 실시간으로 분석 처리하며, 해당 결과를 인메모리에 저장해 주변 시스템과 빠르게 공유함</li>
  <li>이때 대량의 메시지 데이터를 영구 저장하기 위해 하둡을 직접 이용하지는 않음</li>
  <li>유입된 작은 메시지 한 건을 바로 하둡에 저장할 경우 한 개의 HDFS 파일이 생성되는데, 초당 수천 건의 트랜잭션이 발생하는 메시지의 경우 파일 개수가 기하급수적으로 늘어나고, 이로 인해 하둡 클러스터에 지나친 오버헤드가 발생하기 때문</li>
  <li>중간에 메시지를 특정 크기로 모았다가 한번에 적재하거나, 대규모 트랜잭션 데이터를 처리하는 데 최적화된 칼럼 지향형 NoSQL DB 주로 이용</li>
</ul>

<p><br /></p>

<h2 id="2-hbase">2. HBASE</h2>
<h3 id="1-hbase-소개">1) HBASE 소개</h3>
<ul>
  <li>하둡 기반의 칼럼 지향 NoSQL 데이터베이스</li>
  <li>스키마 변경이 자유롭고, <code class="language-plaintext highlighter-rouge">리전</code>이라는 수십~수백 대의 분산 서버로 <strong>샤딩</strong>과 <strong>복제</strong>등의 기능을 지원해 성능과 안정성을 보장하는 특징을 가짐</li>
  <li>특히 하둡의 확장성과 내고장성을 그대로 이용할 수 있어 대규모 실시간 데이터 처리를 위한 스피트 레이어 저장소에 주로 사용됨</li>
</ul>

<p><br /></p>

<h3 id="2-주요-구성-요소">2) 주요 구성 요소</h3>

<table>
  <thead>
    <tr>
      <th>주요 구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTable</td>
      <td>칼럼 기반 데이터 구조를 정의한 테이블 <br /> 공통점이 있는 칼럼들의 그룹을 묶은 **칼럼 패밀리**와 테이블의 로우를 식별해서 접근하기 위한 **로우키**로 구성</td>
    </tr>
    <tr>
      <td>HMaster</td>
      <td>HRegion 서버를 관리하며, HRegion들이 속한 HRegion 서버의 메타 정보 관리</td>
    </tr>
    <tr>
      <td>HRegion</td>
      <td>HTable의 크기에 따라 자동으로 수평 분할이 발생하고, 이때 분할된 블록을 HRegion 단위로 지정</td>
    </tr>
    <tr>
      <td>HRegionServer</td>
      <td>분산 노드별 HRegionServer가 구성되며, 하나의 HRegionServer에는 다수의 HRegion이 생성되어 HRegion 관리</td>
    </tr>
    <tr>
      <td>Store</td>
      <td>하나의 Store에는 칼럼 패밀리가 저장 및 관리되며, MemStore와 HFile로 구성됨</td>
    </tr>
    <tr>
      <td>MemStore</td>
      <td>Store 내의 데이터를 인메모리에 저장 및 관리하는 데이터 캐시 영역</td>
    </tr>
    <tr>
      <td>HFile</td>
      <td>Store 내의 데이터를 스토리지에 저장 및 관리하는 영구 저장 영역</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="3-hbase-아키텍처">3) HBase 아키텍처</h3>
<ul>
  <li>가장 큰 특징은 하둡의 <strong>HDFS</strong>를 기반으로 설치 및 구성된다는 것</li>
  <li>그로 인해 <strong>분산 데이터베이스 아키텍처</strong>를 채택하고 있으며,</li>
  <li>HDFS의 가용성과 확장성을 그대로 물려받음</li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong>클라이언트가 HBase에 데이터를 저장(put)하는 과정</strong>
<img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/2.png" alt="" /></p>
  </li>
  <li>클라이언트가 HBase 테이블에 특정 데이터를 저장하기 전, 주키퍼를 통해 HTable의 기본 정보와 해당 HRegion의 위치 정보를 알아냄</li>
  <li>해당 정보를 기반으로 클라이언트가 직접 HRegionServer로 연결되어 HRegion의 Memory 영역인 MemStore에 데이터 저장</li>
  <li>이때 MemStore에 저장된 데이터는 특정 시점이 되면 HFile로 HDFS에 플러시(Flush)되고, HFile은 HRegion의 상황에 따라 최적의 HFile로 재구성되는 작업이 이루어짐</li>
  <li>이러한 플러시 과정들을 HBase에서는 <code class="language-plaintext highlighter-rouge">Minor/Major Compaction</code>이라고 함</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>HBase에서 특정 데이터를 가져오는 과정</strong></li>
  <li>주키퍼를 통해 로우키(RowKey)에 해당하는 데이터의 위치 정보를 알아냄</li>
  <li>해당 HRegionServer의 Memory 영역인 MemStore에서 데이터를 가져옴으로써 디스크 I/O를 최소화하면서 빠른 응답 속도 보장</li>
  <li>만일 데이터가 MemStore에서 플러시되어 존재하지 않으면 HFile 영역으로 이동해 데이터 찾게 되는데, 이때 HBase와 HDFS 사이의 모든 데이터 스트림 라인들은 항상 열려있으므로 레이턴시가 발생하지 않음  <br />
(레이턴시: 시간 지연, 하나의 데이터 패킷을 한 지점에서 다른 지점으로 보내는데 소요되는 시간)</li>
</ul>

<p><br /></p>

<h2 id="4-hbase-활용-방안">4) HBase 활용 방안</h2>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/3.png" alt="" /></p>

<ul>
  <li>앞서 CH03에서 Flume을 이용해 수집한 스마트카 운전자의 운행 정보를 Kafka까지 전송했음</li>
  <li>이번 장에서는 Kafka에 저장되어 있는 데이터를 Storm이 받아서 HBase의 테이블에 모두 적재</li>
  <li>또한, HBase에 저장된 스마트카 운전자의 운행 정보를 특정 조건에 따라 필터링해서 신속하게 조회해 보고, 하이브 핸들러를 이용해 HBase에 저장된 데이터와 하이브 데이터를 동시에 활용해봄</li>
</ul>

<p><br /></p>

<h2 id="3-redis">3. Redis</h2>
<h3 id="1-레디스-소개">1) 레디스 소개</h3>
<ul>
  <li>분산 캐시 시스템이면서, NoSQL DB처럼 대규모 데이터 관리 능력도 갖춘 IMDG(In-Memory Data Grid) 소프트웨어</li>
  <li>키/값 형식의 데이터 구조를 분산 서버 상의 메모리에 저장하면서 고성능의 응답 속도 보장</li>
  <li>다양한 데이터 타입을 지원하기 때문에 데이터를 구조화해서 저장할 수 있어, 단순 키/값 이상의 데이터 복잡성도 처리할 수 있음</li>
  <li>인메모리 데이터를 영구적으로 저장할 수 있는 스냅샷 기능 제공</li>
  <li>데이터의 유실에 대비해 AOF(Append Only File) 기능으로 정합성 보장</li>
  <li>NoSQL의 특징인 데이터의 샤딩과 복제도 지원하여 높은 성능이 필요한 서비스에서 많이 사용됨</li>
</ul>

<p><br /></p>

<h3 id="2-주요-구성-요소-1">2) 주요 구성 요소</h3>

<table>
  <thead>
    <tr>
      <th>주요 구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Master</td>
      <td>분산 노드 간의 데이터 복제와 Slave 서버의 관리를 위한 Master 서버</td>
    </tr>
    <tr>
      <td>Slave</td>
      <td>다수의 Slave 서버는 주로 읽기 요청을 처리하고, Master 서버는 쓰기 요청을 처리</td>
    </tr>
    <tr>
      <td>Sentinel</td>
      <td>레디스 3.x부터 지원하는 기능으로, Master 서버에 문제가 발생할 경우 새로운 Master를 선출하는 기능</td>
    </tr>
    <tr>
      <td>Replication</td>
      <td>Master 서버에 쓰인 내용을 Slave 서버로 복제해서 동기화 처리</td>
    </tr>
    <tr>
      <td>AOF / Snapshot</td>
      <td>데이터를 영구적으로 저장하는 기능으로, 명령어를 기록하는 AOF와 스냅샷 이미지 파일 방식 지원</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="3-레디스-아키텍처">3) 레디스 아키텍처</h3>
<ul>
  <li>3.x에서부터 HA 기능이 강화되면서 클러스터의 완성도가 높아짐</li>
  <li>요구사항과 데이터의 샤딩 및 복제 구성 방식에 따라 세가지 아키텍처 구성 가능</li>
</ul>

<p><br /></p>

<h4 id="1-레디스-아키텍처-1">1) 레디스 아키텍처 1</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/4.png" alt="" /></p>
<ul>
  <li>Single Master 형식</li>
  <li>개발과 테스트 환경에 주로 사용됨</li>
  <li>설치하기가 쉽고 단일 서버만으로도 빠른 응답 속도와 안정적인 기능을 제공함으로써 소규모이면서 중요도가 비교적 낮은 시스템 간의 데이터 공유에도 종종 사용됨</li>
</ul>

<p><br /></p>

<h4 id="2-레디스-아키텍처-2">2) 레디스 아키텍처 2</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/5.png" alt="" /></p>
<ul>
  <li>Single Master / Multi Slave 형식</li>
  <li>Master에 쓰여진 데이터는 복제를 통해 Slave 노드로 복제되면서 데이터 정합성 유지</li>
  <li>쓰기 / 읽기 노드를 분리해서 전체적인 성능을 향상시킨 구성</li>
  <li>Slave 2와 같이 읽기 노드를 추가해서 성능을 극대화할 수 있음</li>
</ul>

<p><br /></p>

<h4 id="3-레디스-아키텍처-3">3) 레디스 아키텍처 3</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/6.png" alt="" /></p>
<ul>
  <li>버전 3.x부터 지원되는 HA 클러스터링 구조</li>
  <li>아키텍처 2는 두가지 문제점이 있음
    <ul>
      <li>Master 서버 장애 발생 시 쓰기 요청이 실패하면서 데이터 유실이 발생할 수 있는 취약한 구조</li>
      <li>클라이언트가 쓰기 노드와 읽기 노드를 알고 있으야 하므로 클라이언트 프로그램에 복잡도 발생</li>
    </ul>
  </li>
  <li>이러한 문제점 극복을 위해 <code class="language-plaintext highlighter-rouge">Sentinel</code>이라는 노드 모니터링/제어 컴포넌트 추가</li>
  <li>Sentinel이 노드들을 모니터링하고 있다가, Master 서버에 문제가 발생하면 Slave 노드 중 하나를 Master 노드로 지정하고, 문제가 됐던 Master 노드와 연결을 끊으면서 HA 기능 제공</li>
</ul>

<p><br /></p>

<h3 id="4-레디스-활용-방안">4) 레디스 활용 방안</h3>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/7.png" alt="" /></p>
<ul>
  <li>스마트카 운전자의 상태 정보를 실시간으로 분석</li>
  <li>분석한 결과를 빠르게 저장하면서 주변 시스템과 공유하기 위한 저장소로 레디스 활용</li>
  <li>위의 그림에서 Storm에서 두 개의 경로로 분리되는 것을 볼 수 있음
    <ul>
      <li>HBase에는 운전자의 모든 상태 정보를 저장</li>
      <li>레디스에는 운전자의 특정 패턴을 감지한 이벤트 결과(과속한 운전자 정보)만 저장</li>
    </ul>
  </li>
  <li>그러면 주변 응용 시스템에서 레디스에 적재된 정보를 빠르게 조회해서 활용하게 됨</li>
</ul>

<p><br /></p>

<h2 id="4-storm">4. Storm</h2>
<h3 id="1-스톰-소개">1) 스톰 소개</h3>
<ul>
  <li>스피드 데이터를 인메모리 상에서 병렬 처리하기 위한 소프트웨어</li>
  <li>스피드 데이터는 원천 시스템의 수많은 이벤트가 만들어내며, 작지만 대규모의 동시다발적이라는 특성이 있음</li>
  <li>이러한 스피드 데이터를 실시간으로 다루기 위해 모든 데이터를 인메모리 상에서 분산 병렬 처리하고, 분산 데이터를 통제하기 위한 강력한 기능(분리, 정제, 통합, 집계 등)과 아키텍처 제공</li>
</ul>

<p><br /></p>

<ul>
  <li>실시간 분산 처리 유형으로는 데이터 발생과 동시에 처리하는 <code class="language-plaintext highlighter-rouge">완전 실시간 방식</code>과, 발생한 데이터를 적재한 후 빠르게 배치를 실행하는 <code class="language-plaintext highlighter-rouge">마이크로 배치 방식</code>이 있음</li>
  <li>스톰은 전자에 해당하는 <strong>완전 실시간 방식</strong>으로, 조금의 레이턴시도 허용하지 않는 아키텍처에 적용</li>
</ul>

<p><br /></p>

<h3 id="2-주요-구성-요소-2">2) 주요 구성 요소</h3>

<table>
  <thead>
    <tr>
      <th>주요 구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Spout</td>
      <td>외부로부터 데이터를 유입받아 가공처리해서 튜플을 생성, 이후 해당 튜플을 Bolt에 전송</td>
    </tr>
    <tr>
      <td>Bolt</td>
      <td>튜플을 받아 실제 분산 작업 수행 <br /> 필터링, 집계, 조인 등의 연산을 병렬로 실행</td>
    </tr>
    <tr>
      <td>Topology</td>
      <td>Spout-Bolt의 데이터 처리 흐름 정의 <br /> 하나의 Spout과 다수의 Bolt로 구성</td>
    </tr>
    <tr>
      <td>Nimbus</td>
      <td>Topology를 Supervisor에 배포하고 작업 할당 <br /> Supervisor를 모니터링하다 필요 시 페일오버(Fail-over) 처리</td>
    </tr>
    <tr>
      <td>Worker</td>
      <td>Supervisor 상에서 실행 중인 자바 프로세스로 Spout과 Bolt 실행</td>
    </tr>
    <tr>
      <td>Executor</td>
      <td>Worker 내에서 실행되는 자바 스레드</td>
    </tr>
    <tr>
      <td>Tasker</td>
      <td>Spout과 Bolt 객체가 할당</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="3-스톰-아키텍처">3) 스톰 아키텍처</h3>
<h4 id="1-nimbus와-supervisor">1) Nimbus와 Supervisor</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/s1.png" alt="" /></p>
<ul>
  <li>Nimbus가 자바 프로그램으로 구성된 Topology Jar를 배포하기 위해 주키퍼로부터 Supervisor 정보 알아냄</li>
  <li>그 후 해당 Topology Jar 파일을 각 Supervisor에 전송하면 Supervisor는 해당 Node에서 Worker, Executor를 만들고, Spout과 Bolt가 수행되기 위한 Task도 할당함</li>
  <li>Supervisor가 정상적으로 배포되면, Exeternal Source Application 1에서 발생한 데이터가 Spout을 통해 유입되기 시작</li>
  <li>이를 다시 Bolt가 받아 데이터를 분산 처리하고, 처리 결과는 Bolt를 통해 타깃 시스템인 Exeternal Target Application 2로 전송됨</li>
  <li>이때 Task, Executor 개수를 증가시키면서 대규모 병렬 처리가 가능해지고, Spout과 Bolt의 성능이 향상됨</li>
</ul>

<p><br /></p>

<ul>
  <li>매우 견고한 장애 복구 기능도 제공</li>
  <li>만약 특정 Supervisor가 생성한 Worker 프로세스에 심각한 문제가 발생해 종료되면 Supervisor는 새로운 Worker 프로세스 다시 생성</li>
  <li>이때 처리중이던 데이터들(튜플)은 이전 수신지로 롤백되고, Topology가 다시 정상적으로 복구되면 롤백 시점부터 다시 처리하면서 데이터 정합성 보장</li>
</ul>

<p><br /></p>

<h3 id="4-스톰-활용-방안">4) 스톰 활용 방안</h3>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/s2.png" alt="" /></p>
<ul>
  <li>파일럿 프로젝트에서 스톰은 스마트카 운전자의 실시간 운행 정보를 대상으로 <strong>데이터 라우팅과 스트리밍 처리</strong>에 활용될 것</li>
  <li>카프카의 Spout을 통해 유입되는 모든 운전자의 운행 정보 데이터는 두 개의 Bolt (HBase Bolt / Redis Bolt)로 나눠져서 처리됨
    <ul>
      <li>HBase Bolt는 모든 운행 정보를 정제없이 HBase로 곧바로 적재</li>
      <li>Redis Bolt는 <code class="language-plaintext highlighter-rouge">에스퍼</code>라는 룰 엔진이 감지한 이상 운행 패턴의 정보만 레디스 서버에 저장</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="4-esper">4. Esper</h2>
<h3 id="1-에스퍼-소개">1) 에스퍼 소개</h3>
<ul>
  <li>실시간 스트리밍 데이터의 복잡한 이벤트 처리가 필요할 때 사용하는 룰 엔진</li>
  <li>스톰은 실시간으로 발생하는 데이터로부터 복잡한 패턴을 찾고, 그 패턴에 따른 이벤트 처리하는 것은 쉽지 않음</li>
  <li>실시간으로 발생하는 데이터 간의 관계를 복합적으로 판단 및 처리하는 것을  <code class="language-plaintext highlighter-rouge">CEP</code>라고 하는데, 에스퍼가 이 CEP 기능을 제공함</li>
</ul>

<p><br /></p>

<h3 id="2-주요-구성-요소-3">2) 주요 구성 요소</h3>

<table>
  <thead>
    <tr>
      <th>주요 구성 요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Event</td>
      <td>실시간 스트림으로 발생하는 데이터들의 특정 흐름 또는 패턴 정의</td>
    </tr>
    <tr>
      <td>EPL</td>
      <td>유사 SQL을 기반으로 하는 이벤트 데이터 처리 스크립트 언어</td>
    </tr>
    <tr>
      <td>Input Adapter</td>
      <td>소스로부터 전송되는 데이터를 처리하기 위한 어댑터 제공 (CSV, Socket, JDBC, http 등)</td>
    </tr>
    <tr>
      <td>Output Adapter</td>
      <td>타깃으로 전송하는 데이터를 처리하기 위한 어댑터 제공 (HFS, CSV, Socket, Email, Http 등)</td>
    </tr>
    <tr>
      <td>Window</td>
      <td>실시간 스트림 데이터로부터 특정 시간 또는 개수를 설정한 이벤트들을 메모리 상에 등록한 후 EPL을 통해 결과 추출</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="3-에스퍼-아키텍처">3) 에스퍼 아키텍처</h3>
<h4 id="1-에스퍼-아키텍처-1">1) 에스퍼 아키텍처 1</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/e1.png" alt="" /></p>
<ul>
  <li>에스퍼는 CEP(Complex Event Processing) 엔진</li>
  <li><strong>엔진</strong>은 단순 자바 라이브러리 프로그램</li>
  <li>애플리케이션 서버(톰캣, 제이보스, OSGI, 스톰 등) 또는 애플리케이션의 컨텍스트에 에스퍼 라이브러리를 설치하고, 해당 라이브러리를 이용해 CEP 프로그래밍을 하는 단순 아키텍처</li>
</ul>

<p><br /></p>

<h4 id="2-에스퍼-아키텍처2">2) 에스퍼 아키텍처2</h4>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/e2.png" alt="" /></p>
<ul>
  <li>에스퍼의 EPL을 이용해 대규모 분산 아키텍처를 구성할 때는 룰을 통합 관리하고, 분산 노드에 일관되게 적용하기 위해 위 이미지처럼 다소 복잡한 구성 필요</li>
  <li>이때 분산된 응용 서버에 에스퍼 엔진을 설치하고, 에스퍼 엔진들이 동일한 EPL 룰을 동작으로 일괄 로딩하기 위해 EPL 공유 저장소가 이용됨</li>
</ul>

<p><br /></p>

<h3 id="4-에스퍼-활용-방안">4) 에스퍼 활용 방안</h3>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/e3.png" alt="" /></p>
<ul>
  <li>파일럿 프로젝트에서는 운전자의 운행 데이터를 실시간으로 분석하기 위해 데스퍼 EPL 활용</li>
  <li>EPL은 30초 동안의 평균 시속을 체크해서 80km/h를 초과하는 운전자 이벤트 정보를 실시간으로 감지할 수 있도록 룰 정의</li>
  <li>해당 이벤트 데이터는 감지 즉시 레디스에 적재되어 과속한 차량 정보만 관리할 수 있게 됨</li>
</ul>

<p><br /></p>

<h2 id="5-실시간-적재-아키텍처">5. 실시간 적재 아키텍처</h2>
<h3 id="1-실시간-적재-요구사항">1) 실시간 적재 요구사항</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">요구사항 1</code> : 차량의 다양한 장치로부터 발생하는 로그 파일을 수집해서 기능별 상태 점검</li>
  <li><code class="language-plaintext highlighter-rouge">요구사항 2</code> : 운전자의 운행 정보가 담긴 로그를 실시간으로 수집해서 주행 패턴 분석</li>
</ul>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>실시간 적재 요구사항 구체화</th>
      <th>분석 및 해결 방안</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1. 1초 간격으로 발생하는 100명의 운행 정보(1건: 약 4KB는 손실없이 적재해야 함</td>
      <td>카프카와 스톰을 이용해 수집한 데이터에 대해 분산 처리 및 무결성 보장, 분산 처리가 완료된 데이터는 HBase에 적재</td>
    </tr>
    <tr>
      <td>2. 적재한 운행 정보를 대상으로 조건 검색이 가능해야 하며, 필요시 수정도 가능해야 함</td>
      <td>HBase의 테이블에 적재된 데이터는 **스캔** 조건으로 검색하며, 저장(Put) 기능을 이용해 기적재한 데이터에 대해 칼럼 기반으로 수정</td>
    </tr>
    <tr>
      <td>3. 운전자의 운행 정보 중 30초를 기준으로 평균 속도가 80km/h를 초과한 정보는 분리 적재함</td>
      <td>에스퍼의 EPL에서 사용자별로 운행 정보를 그루핑하고, 30초의 윈도우 타임 조건으로 평균 시속 집계 및 임계치별 이벤트 정의</td>
    </tr>
    <tr>
      <td>4. 과속한 차량을 분리 적재하기 위한 조건은 별도의 룰로 정의하고 쉽게 수정할 수 있어야 함</td>
      <td>과속 기준을 80km/h에서  100km/h로 수정해야 할 경우 EPL의 평균 속도를 체크하는 조건값만 수정</td>
    </tr>
    <tr>
      <td>5. 분리 적재한 데이터는 외부 애플리케이션이 빠르게 접근하고 조회할 수 있게 해야 함</td>
      <td>실시간 이벤트로 감지된 데이터는 인메모리 기반 저장소인 **레디스**에 적재하여 외부 애플리케이션에서 빠르게 조회</td>
    </tr>
    <tr>
      <td>6. 레디스에 적재한 데이터는 저장소의 공간을 효율적으로 사용하기 위해 1주일이 지나면 영구적으로 삭제함</td>
      <td>레디스 클라이언트 라이브러리인 **제디스(Jedis) 클라이언트를 이용해 데이터 적재 시 만료(Expire) 시간을 설정해 자동으로 영구 삭제 처리</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="2-실시간-적재-아키텍처">2) 실시간 적재 아키텍처</h3>
<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/실시간적재아키텍처.png" alt="" /></p>
<ul>
  <li>CH03에서는 플럼의 DriverCarInfo 에이전트에서 수집한 운전자 운행 정보를 카프카의 토픽에 실시간으로 전송함</li>
  <li>Ch05에서는 스톰의 카프카-Spout을 이용해 카프카의 토픽에 저장되어 있는 운전자 운행 정보를 가져와 처리하고, 카프카-Bolt에서 이벤트 조건에 따라 레디스와 HBase에 각각 분리 적재함</li>
</ul>

<p><br /></p>

<h4 id="스톰의-실시간-데이터-처리">스톰의 실시간 데이터 처리</h4>
<ul>
  <li>스톰은 카프카로부터 수신받은 운행 정보 데이터를 분산 처리하고, 최종 목적지 저장소에 적재하는 역할</li>
  <li>이때 빠르게 유입되는 데이터로부터 의미 있는 패턴을 발견하기 위해 에스퍼 엔진 이용</li>
  <li>그림에서 ⓵)
    <ul>
      <li>스톰의 Spout가 카프카의 토픽으로부터 운전자의 실시간 운행 정보를 수신받아 첫 번째 볼트에 전송</li>
      <li>해당 Bolt에서는 모든 운행 정보를 HBase Bolt로 전송하면서, 에스퍼의 EPL에서 정의한 조건에 따라 과속한 차량의 정보를 레디스 Bolt에 전송</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="hbase에-모든-운전자-운행-정보-적재">HBase에 모든 운전자 운행 정보 적재</h4>
<ul>
  <li>그림에서 ⓶)
    <ul>
      <li>HBase의 테이블에는 <code class="language-plaintext highlighter-rouge">차량번호+발생일시</code>를 로우키로 해서 8개의 칼럼의 구조로 모든 스마트카 운전자의 운행 정보가 적재됨</li>
      <li><strong>칼럼</strong> (발생일시, 차량번호, 가속 페달, 브레이크 페달, 운전대 회전각, 방향지시등, 주행 속도, 주행 구역)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="레디스에-과속한-운전자-정보-적재">레디스에 과속한 운전자 정보 적재</h4>
<ul>
  <li>그림에서 ⓷)
    <ul>
      <li>레디스에 적재될 때는 현재 날짜를 키로 해서 과속한 차량의 정보를 세트 데이터 구조로 적재</li>
      <li>적재 영속 시간은 5시간으로 하며, 이후에 만료 처리되어 메모리에서 자동으로 삭제됨</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="6-실시간-적재-환경-구성">6. 실시간 적재 환경 구성</h2>
<ul>
  <li>3개의 소프트웨어 추가 설치
    <ul>
      <li>CM으로 <code class="language-plaintext highlighter-rouge">HBase</code>를 Server01, 02에 있는 데이터노드에 설치</li>
      <li><code class="language-plaintext highlighter-rouge">레디스</code>와 <code class="language-plaintext highlighter-rouge">스톰</code>은 CM에 포함되어 있지 않은 소프트웨어로 별도의 패키지로 설치</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/bokyung124/hadoop-pilot-pjt/raw/main/img/CH05/last.png" alt="" /></p>]]></content><author><name>BoKyung</name></author><category term="Hadoop" /><category term="study" /><category term="Hadoop" /><category term="파일럿프로젝트" /><summary type="html"><![CDATA[[출처: 실무로 배우는 빅데이터 기술, 김강원 저]]]></summary></entry></feed>