---
title: "[DEV] 1주차. 자료구조/알고리즘(5)"
last_modified_at: 2023-10-20T13:00:00-05:00
layout: post
categories:
    - Data Engineering
excerpt: 
toc: true
toc_sticky: true
toc_icon: "cog"
author_profile: true
mathjax: true
tag: [DevCourse, TIL, DE, KDT]
---

## 1. Heap 대표 문제 - 더 맵게

### Heaps 
<img width="362" alt="스크린샷 2023-10-20 오후 6 56 15" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/532ffaae-955b-4506-b7ab-8d2f05d09ad5">

- 최대/최소 원소를 상수 시간으로 빠르게 찾을 수 있음
- 연산
    - 힙 구성 (heapify)
        - $O(nlogn)$
    - 삽입 (insert)
        - $O(logn)$
    - 삭제 (remove)
        - 최대/최소 원소를 하나 꺼내서 없애는 것
        - $O(logn)$
- 완전 이진 트리
    - 배열을 이용해서 구현 가능!
    - 공간 효율성이 높음
- 응용
    - 정렬 (heap sort)
        - $O(nlogn)$
    - 우선 순위 큐 (prioirty queue)
        - 우선 순위에 따라 빠져나오는 큐
    

### 문제 설명
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

`섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)`

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.

Leo가 가진 음식의 스코빌 지수를 담은 배열 `scoville`과 원하는 스코빌 지수 `K`가 주어질 때, 모든 음식의 스코빌 지수를 `K` 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

### 제한 사항
- `scoville`의 길이는 1 이상 1,000,000 이하입니다.
- `K`는 0 이상 1,000,000,000 이하입니다.
- `scoville`의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 `K` 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

### 입출력 예
<img width="279" alt="스크린샷 2023-10-20 오후 6 33 37" src="https://github.com/bokyung124/bokyung124.github.io/assets/53086873/bc206ae6-2db7-4788-a4bb-a8e480cd3a39">

### 방법 1
- `scoville` 배열 정렬
- 앞에서부터 공식에 따라 계산
    - (가장 작은 수) + (두번째로 작은 수 * 2)
- 계산된 결과를 배열에 삽입
    - 순서에 맞게!
- 모든 원소가 7보다 클 때까지 위 과정 반복

#### 알고리즘 복잡도
- 최악의 경우
    - 수가 하나 남을 때까지 섞어야 하는 경우 (n-1 회)
- 각 단계 (섞는 일) 에서 요구되는 계산량
    - 정렬된 리스트에 순서를 맞추어 원소 삽입
    - $O(n)$
- **전체 : $O(n^2)$**
    - 지나치게 높음
    - **Heap** 이용

### 보다 나은 방법
- 최소/최대 원소를 빠르게 꺼내는 방법!
- 힙 (Heap)
    - max heap
    - min heap

### python에서 힙 적용

```python
import heapq

heapq.heapify(L)       # 리스트 L로부터 min heap 구성 
m = heapq.heappop(L)   # min heap L에서 최소값 삭제 (반환)
heapq.heappush(L, x)   # min heap L에 원소 x 삽입
```

### 코드

```python
import heapq

def solution(scoville, K):
    answer = 0   # 섞은 횟수

    heapq.heapify(scoville)
    while True:
        min1 = heapq.heappop(scoville)
        if min1 >= K:
            break
        elif len(scoville) == 0:
            answer = -1
            break
        min2 = heapq.heappop(scoville)
        new_scoville = min1 + (min2 * 2)
        heapq.heappush(scoville, new_scoville)
        answer += 1

    return answer
```

- $O(nlogn)$